  internal sealed class MariaAckConsumerDAL : MariaDALBase, IAckConsumerDAL {
      public MariaAckConsumerDAL(IWorkFlowDALUtil db) : base(db) { }
      public Task<DbRow?> GetByKeyAsync(long ackId, long consumer, DbExecutionLoad load = default)
          => Db.RowAsync(QRY_ACK_CONSUMER.GET_BY_KEY, load, (ACK_ID, ackId), (CONSUMER_ID, consumer)); // FIXED

      public Task<DbRow?> GetByAckGuidAndConsumerAsync(string ackGuid, long consumer, DbExecutionLoad load = default)
          => Db.RowAsync(QRY_ACK_CONSUMER.GET_BY_ACK_GUID_AND_CONSUMER, load, (GUID, ackGuid), (CONSUMER_ID, consumer));

      public Task<long> UpsertByAckIdAndConsumerReturnIdAsync(long ackId, long consumer, int status, DateTime? utcNextDue, DbExecutionLoad load = default)
          => Db.ScalarAsync<long>(QRY_ACK_CONSUMER.UPSERT_RETURN_ID, load, (ACK_ID, ackId),(CONSUMER_ID, consumer),(ACK_STATUS, status), (NEXT_DUE, utcNextDue));

      public Task<int> SetStatusAndDueAsync(long ackId, long consumer, int status, DateTime? utcNextDue, DbExecutionLoad load = default)
          => Db.ExecAsync(QRY_ACK_CONSUMER.SET_STATUS_AND_DUE, load, (ACK_ID, ackId), (CONSUMER_ID, consumer),(ACK_STATUS, status), (NEXT_DUE, utcNextDue));

      public Task<int> SetStatusAndDueByGuidAsync(string ackGuid, long consumer, int status, DateTime? utcNextDue, DbExecutionLoad load = default)
          => Db.ExecAsync(QRY_ACK_CONSUMER.SET_STATUS_AND_DUE_BY_GUID, load, (GUID, ackGuid), (CONSUMER_ID, consumer),(ACK_STATUS, status),(NEXT_DUE, utcNextDue));

      public Task<int> MarkTriggerAsync(long ackId, long consumer, DateTime? utcNextDue, DbExecutionLoad load = default)
          => Db.ExecAsync(QRY_ACK_CONSUMER.MARK_TRIGGER, load,(ACK_ID, ackId),(CONSUMER_ID, consumer),(NEXT_DUE, utcNextDue));

      public Task<DbRows> ListDueByStatusPagedAsync(int status, int skip, int take, DbExecutionLoad load = default)
          => Db.RowsAsync(QRY_ACK_CONSUMER.LIST_DUE_BY_STATUS_PAGED, load,(ACK_STATUS, status),(SKIP, skip),(TAKE, take));

      public Task<DbRows> ListDueByConsumerAndStatusPagedAsync(long consumer, int status, int skip, int take, DbExecutionLoad load = default)
          => Db.RowsAsync(QRY_ACK_CONSUMER.LIST_DUE_BY_CONSUMER_AND_STATUS_PAGED, load,(CONSUMER_ID, consumer), (ACK_STATUS, status),(SKIP, skip),(TAKE, take));

      // Keep these if you still want “non-due” browsing screens:
      public Task<DbRows> ListByStatusPagedAsync(int status, int skip, int take, DbExecutionLoad load = default)
          => Db.RowsAsync(QRY_ACK_CONSUMER.LIST_BY_STATUS_PAGED, load, (ACK_STATUS, status), (SKIP, skip), (TAKE, take));

      public Task<DbRows> ListByConsumerAndStatusPagedAsync(long consumer, int status, int skip, int take, DbExecutionLoad load = default)
          => Db.RowsAsync(QRY_ACK_CONSUMER.LIST_BY_CONSUMER_AND_STATUS_PAGED, load, (CONSUMER_ID, consumer), (ACK_STATUS, status), (SKIP, skip), (TAKE, take));
 
        public Task<int> PushNextDueForDownAsync(long consumerId, int ackStatus, int ttlSeconds, int recheckSeconds, DbExecutionLoad load = default) => Db.ExecAsync(QRY_ACK_CONSUMER.PUSH_NEXT_DUE_FOR_DOWN_BY_CONSUMER_AND_STATUS, load, (CONSUMER_ID, consumerId), (ACK_STATUS, ackStatus), (TTL_SECONDS, ttlSeconds), (RECHECK_SECONDS, recheckSeconds));
 }

   internal sealed class MariaConsumerDAL : MariaDALBase, IConsumerDAL {
     public MariaConsumerDAL(IWorkFlowDALUtil db) : base(db) { }

     public Task<int?> GetIdByEnvIdAndGuidAsync(int envId, string consumerGuid, DbExecutionLoad load = default)
         => Db.ScalarAsync<int?>(QRY_CONSUMER.GET_ID_BY_ENV_ID_AND_GUID, load, (ENV_ID, envId), (CONSUMER_GUID, consumerGuid));

     public Task<int?> GetIdAliveByEnvIdAndGuidAsync(int envId, string consumerGuid, int ttlSeconds, DbExecutionLoad load = default)
         => Db.ScalarAsync<int?>(QRY_CONSUMER.GET_ID_ALIVE_BY_ENV_ID_AND_GUID, load, (ENV_ID, envId), (CONSUMER_GUID, consumerGuid), (TTL_SECONDS, ttlSeconds));

     public Task<int> UpsertBeatByEnvIdAndGuidAsync(int envId, string consumerGuid, DbExecutionLoad load = default)
         => Db.ExecAsync(QRY_CONSUMER.UPSERT_BEAT_BY_ENV_ID_AND_GUID, load, (ENV_ID, envId), (CONSUMER_GUID, consumerGuid));

     public Task<int> UpdateBeatByIdAsync(int consumerId, DbExecutionLoad load = default)
         => Db.ExecAsync(QRY_CONSUMER.UPDATE_BEAT_BY_ID, load, (CONSUMER_ID, consumerId));

     public async Task<IReadOnlyList<int>> ListAliveIdsByEnvIdAsync(int envId, int ttlSeconds, DbExecutionLoad load = default) {
         var rows = await Db.RowsAsync(QRY_CONSUMER.LIST_ALIVE_IDS_BY_ENV_ID, load, (ENV_ID, envId), (TTL_SECONDS, ttlSeconds));
         return rows.Select(r => (int)r["id"]).ToArray();
     }

     public Task<int> IsAliveByIdAsync(int consumerId, int ttlSeconds, DbExecutionLoad load = default)
         => Db.ScalarAsync<int>(QRY_CONSUMER.IS_ALIVE_BY_ID, load, (CONSUMER_ID, consumerId), (TTL_SECONDS, ttlSeconds));

     public Task<int> IsAliveByEnvIdAndGuidAsync(int envId, string consumerGuid, int ttlSeconds, DbExecutionLoad load = default)
         => Db.ScalarAsync<int>(QRY_CONSUMER.IS_ALIVE_BY_ENV_ID_AND_GUID, load, (ENV_ID, envId), (CONSUMER_GUID, consumerGuid), (TTL_SECONDS, ttlSeconds));

     public Task<DateTime?> GetLastBeatByEnvIdAndGuidAsync(int envId, string consumerGuid, DbExecutionLoad load = default)
         => Db.ScalarAsync<DateTime?>(QRY_CONSUMER.GET_LAST_BEAT_BY_ENV_ID_AND_GUID, load, (ENV_ID, envId), (CONSUMER_GUID, consumerGuid));
     public async Task<int> EnsureByEnvIdAndGuidReturnIdAsync(int envId, string consumerGuid, DbExecutionLoad load = default) {
         var id = await GetIdByEnvIdAndGuidAsync(envId, consumerGuid, load);
         if (id.HasValue && id.Value > 0) return id.Value;

         // Insert OR upsert; choose what you have
         if (!string.IsNullOrWhiteSpace(QRY_CONSUMER.UPSERT_BEAT_BY_ENV_ID_AND_GUID)) {
             await UpsertBeatByEnvIdAndGuidAsync(envId, consumerGuid, load);
         } else {
             await Db.ExecAsync(QRY_CONSUMER.INSERT, load, (ENV_ID, envId), (CONSUMER_GUID, consumerGuid));
         }

         id = await GetIdByEnvIdAndGuidAsync(envId, consumerGuid, load);
         if (!id.HasValue || id.Value <= 0) throw new InvalidOperationException($"consumer ensure failed. env={envId}, guid={consumerGuid}");
         return id.Value;
     }
     public Task<int> PushNextDueForDownAsync(long consumerId, int ackStatus, int ttlSeconds, int recheckSeconds, DbExecutionLoad load = default)
 => Db.ExecAsync(QRY_ACK_CONSUMER.PUSH_NEXT_DUE_FOR_DOWN_BY_CONSUMER_AND_STATUS, load, (CONSUMER_ID, consumerId), (ACK_STATUS, ackStatus), (TTL_SECONDS, ttlSeconds), (RECHECK_SECONDS, recheckSeconds));


 }

   public class MariaWorkFlowDALUtil : IWorkFlowDALUtil {
     private readonly IAdapterGateway _agw;
     protected readonly string _key;

     public MariaWorkFlowDALUtil(IAdapterGateway agw, string key) {
         _agw = agw ?? throw new ArgumentNullException(nameof(agw));
         _key = key ?? throw new ArgumentNullException(nameof(key));
     }

     public async Task<int> ExecAsync(string sql, DbExecutionLoad load = default, params DbArg[] args) {
         load.Ct.ThrowIfCancellationRequested();
         var fb = await _agw.NonQueryAsync(new AdapterArgs(_key) { Query = sql}.ForTransaction(load.Handler,false), ToAgwArgs(args));
         if (!fb.Status) throw new InvalidOperationException(fb.Message ?? "NonQuery failed.");
         return fb.Result;
     }
     public async Task<T?> ScalarAsync<T>(string sql, DbExecutionLoad load = default, params DbArg[] args) {
         load.Ct.ThrowIfCancellationRequested();
         var fb = await _agw.ScalarAsync<T>(new AdapterArgs(_key) { Query = sql }.ForTransaction(load.Handler, false), ToAgwArgs(args));
         if (!fb.Status) throw new InvalidOperationException(fb.Message ?? "Scalar failed.");
         return fb.Result;
     }
     public async Task<DbRow?> RowAsync(string sql, DbExecutionLoad load = default, params DbArg[] args) {
         load.Ct.ThrowIfCancellationRequested();
         var fb = await _agw.ReadSingleAsync(new AdapterArgs(_key) { Query = sql }.ForTransaction(load.Handler, false), ToAgwArgs(args));
         if (!fb.Status) throw new InvalidOperationException(fb.Message ?? "ReadSingle failed.");
         return fb.Result;
     }
     public async Task<DbRows> RowsAsync(string sql, DbExecutionLoad load = default, params DbArg[] args) {
         load.Ct.ThrowIfCancellationRequested();
         var fb = await _agw.ReadAsync(new AdapterArgs(_key) { Query = sql }.ForTransaction(load.Handler, false), ToAgwArgs(args));
         if (!fb.Status) throw new InvalidOperationException(fb.Message ?? "Read failed.");
         return fb.Result;
     }

     private static (string key, object value)[] ToAgwArgs(DbArg[]? args) {
         if (args == null || args.Length == 0) return Array.Empty<(string key, object value)>();

         var arr = new (string key, object value)[args.Length];
         for (int i = 0; i < args.Length; i++) {
             // AGW expects object (non-nullable) — convert null to DBNull.Value (safe for DB)
             var v = args[i].Value ?? DBNull.Value;
             arr[i] = (args[i].Name, v);
         }
         return arr;
     }
     public ValueTask DisposeAsync() => ValueTask.CompletedTask;

     public ITransactionHandler CreateNewTransaction() {
         return _agw.GetTransactionHandler(_key);
     }
 }

  public class MariaWorkFlowDAL : MariaWorkFlowDALUtil, IWorkFlowDAL {
     public IBlueprintReadDAL Blueprint { get; }
     public IBlueprintWriteDAL BlueprintWrite { get; }
     public IInstanceDAL Instance { get; }
     public ILifeCycleDAL LifeCycle { get; }
     public ILifeCycleDataDAL LifeCycleData { get; }
     public IHookDAL Hook { get; }
     public IAckDAL Ack { get; }
     public IAckConsumerDAL AckConsumer { get; }
     public ILcAckDAL LcAck { get; }
     public IHookAckDAL HookAck { get; }
     public IAckDispatchDAL AckDispatch { get; }
     public IActivityDAL Activity { get; }
     public IActivityStatusDAL ActivityStatus { get; }
     public IRuntimeDAL Runtime { get; }
     public IRuntimeDataDAL RuntimeData { get; }
     public IConsumerDAL Consumer { get; }
     public MariaWorkFlowDAL(IAdapterGateway agw, string key) : base(agw, key) {
         Blueprint = new MariaBlueprintReadDAL(this);
         BlueprintWrite = new MariaBlueprintWriteDAL(this);
         Instance = new MariaInstanceDAL(this);
         LifeCycle = new MariaLifeCycleDAL(this);
         LifeCycleData = new MariaLifeCycleDataDAL(this);
         Hook = new MariaHookDAL(this);

         Ack = new MariaAckDAL(this);
         AckConsumer = new MariaAckConsumerDAL(this);
         LcAck = new MariaLcAckDAL(this);
         HookAck = new MariaHookAckDAL(this);
         AckDispatch = new MariaAckDispatchDAL(this);

         Activity = new MariaActivityDAL(this);
         ActivityStatus = new MariaActivityStatusDAL(this);

         Runtime = new MariaRuntimeDAL(this);
         RuntimeData = new MariaRuntimeDataDAL(this); 
         Consumer = new MariaConsumerDAL(this);
     }
 }