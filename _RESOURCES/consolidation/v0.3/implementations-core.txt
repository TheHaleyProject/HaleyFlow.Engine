 internal sealed class AckManager : IAckManager {
     private readonly IWorkFlowDAL _dal;
     private readonly Func<long, long, CancellationToken, Task<IReadOnlyList<long>>> _transitionConsumers;
     private readonly Func<long, long, string, CancellationToken, Task<IReadOnlyList<long>>> _hookConsumers;

     public AckManager(IWorkFlowDAL dal, Func<long, long, CancellationToken, Task<IReadOnlyList<long>>>? transitionConsumers = null, Func<long, long, string, CancellationToken, Task<IReadOnlyList<long>>>? hookConsumers = null) {
         _dal = dal ?? throw new ArgumentNullException(nameof(dal));
         _transitionConsumers = transitionConsumers ?? ((dv, iid, ct) => Task.FromResult<IReadOnlyList<long>>(Array.Empty<long>()));
         _hookConsumers = hookConsumers ?? ((dv, iid, code, ct) => Task.FromResult<IReadOnlyList<long>>(Array.Empty<long>()));
     }

     public Task<IReadOnlyList<long>> GetTransitionConsumersAsync(long defVersionId, long instanceId, CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); return _transitionConsumers(defVersionId, instanceId, ct); }

     public Task<IReadOnlyList<long>> GetHookConsumersAsync(long defVersionId, long instanceId, string hookCode, CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); return _hookConsumers(defVersionId, instanceId, hookCode, ct); }

     public async Task<ILifeCycleAckRef> CreateLifecycleAckAsync(long lifecycleId, IReadOnlyList<long> consumerIds, int initialAckStatus, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         if (lifecycleId <= 0) throw new ArgumentOutOfRangeException(nameof(lifecycleId));

         var existingAckId = await _dal.LcAck.GetAckIdByLcIdAsync(lifecycleId, load);
         if (existingAckId.HasValue && existingAckId.Value > 0) {
             await EnsureConsumersAsync(existingAckId.Value, consumerIds, initialAckStatus, load);
             return await GetAckRefByIdAsync(existingAckId.Value, load);
         }

         var ack = await _dal.Ack.InsertReturnRowAsync(load);
         if (ack == null) throw new InvalidOperationException("Ack insert failed.");

         var ackId = ack.GetLong("id");
         var ackGuid = ack.GetString("guid");
         if (ackId <= 0 || string.IsNullOrWhiteSpace(ackGuid)) throw new InvalidOperationException("Ack insert failed (id/guid missing).");

         await _dal.LcAck.AttachAsync(ackId, lifecycleId, load);
         await EnsureConsumersAsync(ackId, consumerIds, initialAckStatus, load);

         return new LifeCycleAckRef { AckId = ackId, AckGuid = ackGuid! };
     }

     public async Task<ILifeCycleAckRef> CreateHookAckAsync(long hookId, IReadOnlyList<long> consumerIds, int initialAckStatus, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         if (hookId <= 0) throw new ArgumentOutOfRangeException(nameof(hookId));

         var existingAckId = await _dal.HookAck.GetAckIdByHookIdAsync(hookId, load);
         if (existingAckId.HasValue && existingAckId.Value > 0) {
             await EnsureConsumersAsync(existingAckId.Value, consumerIds, initialAckStatus, load);
             return await GetAckRefByIdAsync(existingAckId.Value, load);
         }

         var ack = await _dal.Ack.InsertReturnRowAsync(load);
         if (ack == null) throw new InvalidOperationException("Ack insert failed.");

         var ackId = ack.GetLong("id");
         var ackGuid = ack.GetString("guid");
         if (ackId <= 0 || string.IsNullOrWhiteSpace(ackGuid)) throw new InvalidOperationException("Ack insert failed (id/guid missing).");

         await _dal.HookAck.AttachAsync(ackId, hookId, load);
         await EnsureConsumersAsync(ackId, consumerIds, initialAckStatus, load);

         return new LifeCycleAckRef { AckId = ackId, AckGuid = ackGuid! };
     }

     public async Task AckAsync(long consumerId, string ackGuid, AckOutcome outcome, string? message = null, DateTimeOffset? retryAt = null, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         if (consumerId <= 0) throw new ArgumentOutOfRangeException(nameof(consumerId));
         if (string.IsNullOrWhiteSpace(ackGuid)) throw new ArgumentNullException(nameof(ackGuid));

         var status = outcome == AckOutcome.Delivered ? AckStatus.Delivered :
                      outcome == AckOutcome.Processed ? AckStatus.Processed :
                      outcome == AckOutcome.Failed ? AckStatus.Failed :
                      AckStatus.Pending;

         var affected = await _dal.AckConsumer.SetStatusByGuidAsync(ackGuid, consumerId, (int)status, load);
         if (affected <= 0) throw new InvalidOperationException($"AckConsumer not found. guid={ackGuid}, consumer={consumerId}");

         if (outcome == AckOutcome.Retry) {
             var ackId = await _dal.Ack.GetIdByGuidAsync(ackGuid, load);
             if (!ackId.HasValue || ackId.Value <= 0) throw new InvalidOperationException($"Ack not found. guid={ackGuid}");
             await _dal.AckConsumer.SetStatusAsync(ackId.Value, consumerId, (int)AckStatus.Pending, load);
             await _dal.AckConsumer.MarkRetryAsync(ackId.Value, consumerId, load);
         }

         _ = message; _ = retryAt;
     }

     public async Task MarkRetryAsync(long ackId, long consumerId, DateTimeOffset? retryAt = null, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         if (ackId <= 0) throw new ArgumentOutOfRangeException(nameof(ackId));
         if (consumerId <= 0) throw new ArgumentOutOfRangeException(nameof(consumerId));
         await _dal.AckConsumer.SetStatusAsync(ackId, consumerId, (int)AckStatus.Pending, load);
         await _dal.AckConsumer.MarkRetryAsync(ackId, consumerId, load);
         _ = retryAt;
     }

     public Task SetStatusAsync(long ackId, long consumerId, int ackStatus, DbExecutionLoad load = default) { load.Ct.ThrowIfCancellationRequested(); return _dal.AckConsumer.SetStatusAsync(ackId, consumerId, ackStatus, load); }

     public async Task<IReadOnlyList<ILifeCycleDispatchItem>> ListPendingLifecycleDispatchAsync(long consumerId, int ackStatus, DateTime utcOlderThan, int skip, int take, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         var rows = await _dal.AckDispatch.ListPendingLifecycleReadyPagedAsync(consumerId, ackStatus, utcOlderThan, skip, take, load);
         var list = new List<ILifeCycleDispatchItem>(rows.Count);

         foreach (var r in rows) {
             load.Ct.ThrowIfCancellationRequested();

             var evt = new LifeCycleTransitionEvent {
                 ConsumerId = r.GetLong("consumer"),
                 InstanceId = r.GetLong("instance_id"),
                 DefinitionVersionId = r.GetNullableLong("def_version_id") ?? 0,
                 ExternalRef = r.GetString("external_ref") ?? string.Empty,
                 RequestId = null,
                 OccurredAt = r.GetDateTimeOffset("lc_created") ?? DateTimeOffset.UtcNow,
                 AckGuid = r.GetString("ack_guid") ?? string.Empty,
                 AckRequired = true,
                 Payload = null,
                 LifeCycleId = r.GetLong("lc_id"),
                 FromStateId = r.GetLong("from_state"),
                 ToStateId = r.GetLong("to_state"),
                 EventId = r.GetLong("event_id"),
                 EventCode = r.GetNullableInt("event_code") ?? 0,
                 EventName = r.GetString("event_name") ?? string.Empty,
                 PrevStateMeta = null,
                 PolicyId = r.GetNullableLong("policy_id"),
                 PolicyHash = r.GetString("policy_hash"),
                 PolicyJson = r.GetString("policy_json")
             };

             list.Add(new LifeCycleDispatchItem {
                 Kind = LifeCycleDispatchKind.Lifecycle,
                 AckId = r.GetLong("ack_id"),
                 AckGuid = r.GetString("ack_guid") ?? string.Empty,
                 ConsumerId = r.GetLong("consumer"),
                 AckStatus = r.GetInt("status"),
                 RetryCount = r.GetInt("retry_count"),
                 LastRetryUtc = r.GetDateTime("last_retry") ?? DateTime.UtcNow,
                 Event = evt
             });
         }

         return list;
     }

     public async Task<IReadOnlyList<ILifeCycleDispatchItem>> ListPendingHookDispatchAsync(long consumerId, int ackStatus, DateTime utcOlderThan, int skip, int take, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         var rows = await _dal.AckDispatch.ListPendingHookReadyPagedAsync(consumerId, ackStatus, utcOlderThan, skip, take, load);
         var list = new List<ILifeCycleDispatchItem>(rows.Count);

         foreach (var r in rows) {
             load.Ct.ThrowIfCancellationRequested();

             var evt = new LifeCycleHookEvent {
                 ConsumerId = r.GetLong("consumer"),
                 InstanceId = r.GetLong("instance_id"),
                 DefinitionVersionId = r.GetNullableLong("def_version_id") ?? 0,
                 ExternalRef = r.GetString("external_ref") ?? string.Empty,
                 RequestId = null,
                 OccurredAt = r.GetDateTimeOffset("hook_created") ?? DateTimeOffset.UtcNow,
                 AckGuid = r.GetString("ack_guid") ?? string.Empty,
                 AckRequired = true,
                 Payload = null,
                 HookId = r.GetLong("hook_id"),
                 StateId = r.GetLong("state_id"),
                 OnEntry = r.GetBool("on_entry"),
                 HookCode = r.GetString("route") ?? string.Empty,
                 OnSuccessEvent = null,
                 OnFailureEvent = null,
                 NotBefore = null,
                 Deadline = null
             };

             list.Add(new LifeCycleDispatchItem {
                 Kind = LifeCycleDispatchKind.Hook,
                 AckId = r.GetLong("ack_id"),
                 AckGuid = r.GetString("ack_guid") ?? string.Empty,
                 ConsumerId = r.GetLong("consumer"),
                 AckStatus = r.GetInt("status"),
                 RetryCount = r.GetInt("retry_count"),
                 LastRetryUtc = r.GetDateTime("last_retry") ?? DateTime.UtcNow,
                 Event = evt
             });
         }

         return list;
     }

     public async Task<int> CountPendingLifecycleDispatchAsync(int ackStatus, DateTime utcOlderThan, DbExecutionLoad load = default) { load.Ct.ThrowIfCancellationRequested(); return (await _dal.AckDispatch.CountPendingLifecycleReadyAsync(ackStatus, utcOlderThan, load)) ?? 0; }

     public async Task<int> CountPendingHookDispatchAsync(int ackStatus, DateTime utcOlderThan, DbExecutionLoad load = default) { load.Ct.ThrowIfCancellationRequested(); return (await _dal.AckDispatch.CountPendingHookReadyAsync(ackStatus, utcOlderThan, load)) ?? 0; }

     private async Task EnsureConsumersAsync(long ackId, IReadOnlyList<long> consumerIds, int initialAckStatus, DbExecutionLoad load) {
         load.Ct.ThrowIfCancellationRequested();
         var ids = NormalizeConsumers(consumerIds);
         for (var i = 0; i < ids.Count; i++) {
             load.Ct.ThrowIfCancellationRequested();
             await _dal.AckConsumer.UpsertByAckIdAndConsumerReturnIdAsync(ackId, ids[i], initialAckStatus, load); // DAL does EXISTS->INSERT
         }
     }

     private async Task<ILifeCycleAckRef> GetAckRefByIdAsync(long ackId, DbExecutionLoad load) {
         load.Ct.ThrowIfCancellationRequested();
         var row = await _dal.Ack.GetByIdAsync(ackId, load);
         if (row == null) throw new InvalidOperationException($"Ack not found. id={ackId}");
         var guid = row.GetString("guid");
         if (string.IsNullOrWhiteSpace(guid)) throw new InvalidOperationException($"Ack guid missing. id={ackId}");
         return new LifeCycleAckRef { AckId = ackId, AckGuid = guid! };
     }

     private static IReadOnlyList<long> NormalizeConsumers(IReadOnlyList<long> consumerIds) {
         if (consumerIds == null || consumerIds.Count == 0) return Array.Empty<long>();
         var set = new HashSet<long>();
         for (var i = 0; i < consumerIds.Count; i++) if (consumerIds[i] > 0) set.Add(consumerIds[i]);
         if (set.Count == 0) return Array.Empty<long>();
         var arr = new long[set.Count];
         set.CopyTo(arr);
         return arr;
     }
 }

   public sealed class BlueprintImporter : IBlueprintImporter {
      private readonly IWorkFlowDAL _dal;
      public BlueprintImporter(IWorkFlowDAL dal) { _dal = dal ?? throw new ArgumentNullException(nameof(dal)); }
      public async Task<long> ImportDefinitionJsonAsync(int envCode, string envDisplayName, string definitionJson, CancellationToken ct = default) {
          ct.ThrowIfCancellationRequested();
          if (string.IsNullOrWhiteSpace(definitionJson)) throw new ArgumentNullException(nameof(definitionJson));

          using var doc = JsonDocument.Parse(definitionJson);
          var root = doc.RootElement;

          var defNode = root.TryGetProperty("definition", out var d) ? d : root;
          var defName = ReqString(defNode, "name") ?? ReqString(defNode, "displayName") ?? ReqString(defNode, "defName") ?? throw new InvalidOperationException("definition.name/displayName missing.");
          var defDesc = TryString(defNode, "description");
          var requestedVer = TryInt(defNode, "version") ?? 0;

          var transaction = _dal.CreateNewTransaction();
          using var tx = transaction.Begin(false);
          var load = new DbExecutionLoad(ct, transaction);
          var committed = false;

          try {
              var envId = await _dal.BlueprintWrite.EnsureEnvironmentByCodeAsync(envCode, envDisplayName, load);
              var defId = await _dal.BlueprintWrite.EnsureDefinitionByEnvIdAsync(envId, defName, defDesc, load);

              var nextVer = await _dal.Blueprint.GetNextDefVersionNumberByEnvCodeAndDefNameAsync(envCode, defName, load) ?? 1;
              var verToUse = requestedVer > 0 ? requestedVer : nextVer;
              if (requestedVer > 0 && requestedVer != nextVer) throw new InvalidOperationException($"JSON version={requestedVer} but DB next_version={nextVer}. Import rejected.");

              var defVersionId = await _dal.BlueprintWrite.InsertDefVersionAsync(defId, verToUse, definitionJson, load);

              var categoryMap = await ImportCategoriesFromStatesAsync(root, load);
              var eventsByCode = await ImportEventsAsync(defVersionId, root, load);
              var statesByName = await ImportStatesAsync(defVersionId, root, categoryMap, eventsByCode, load);
              await ImportTransitionsAsync(defVersionId, root, statesByName, eventsByCode, load);

              tx.Commit();
              committed = true;
              return defVersionId;
          } catch {
              if (!committed) tx.Rollback();
              throw;
          }
      }

      public async Task<long> ImportPolicyJsonAsync(int envCode, string envDisplayName, string policyJson, CancellationToken ct = default) {
          ct.ThrowIfCancellationRequested();
          if (string.IsNullOrWhiteSpace(policyJson)) throw new ArgumentNullException(nameof(policyJson));

          using var doc = JsonDocument.Parse(policyJson);
          var root = doc.RootElement;

          var defName = TryString(root, "defName") ?? TryString(root, "definitionName") ?? TryString(root, "name") ?? TryString(root, "displayName");
          if (string.IsNullOrWhiteSpace(defName)) throw new InvalidOperationException("Policy JSON missing defName/definitionName/name/displayName.");

          var transaction = _dal.CreateNewTransaction();
          using var tx = transaction.Begin(false);
          var load = new DbExecutionLoad(ct, transaction);
          var committed = false;
          try {
              var envId = await _dal.BlueprintWrite.EnsureEnvironmentByCodeAsync(envCode, envDisplayName, load);
              _ = await _dal.BlueprintWrite.EnsureDefinitionByEnvIdAsync(envId, defName!, description: null, load);

              var hash = Hash48(policyJson);
              var policyId = await _dal.BlueprintWrite.EnsurePolicyByHashAsync(hash, policyJson, load);

              await _dal.BlueprintWrite.AttachPolicyToDefinitionByEnvCodeAndDefNameAsync(envCode, defName!, policyId, load);

              tx.Commit();
              committed = true;
              return policyId;
          } catch {
              if (!committed) tx.Rollback();
              throw;
          }
      }

      private async Task<Dictionary<string, int>> ImportCategoriesFromStatesAsync(JsonElement root, DbExecutionLoad load) {
          var map = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
          if (!root.TryGetProperty("states", out var states) || states.ValueKind != JsonValueKind.Array) return map;

          foreach (var s in states.EnumerateArray()) {
              var cat = TryString(s, "category");
              if (string.IsNullOrWhiteSpace(cat)) continue;

              var key = N(cat);
              if (map.ContainsKey(key)) continue;

              var id = await _dal.BlueprintWrite.EnsureCategoryByNameAsync(cat!, load);
              map[key] = id;
          }

          return map;
      }

      private async Task<Dictionary<int, EventDef>> ImportEventsAsync(long defVersionId, JsonElement root, DbExecutionLoad load) {
          var byCode = new Dictionary<int, EventDef>();
          if (!root.TryGetProperty("events", out var events) || events.ValueKind != JsonValueKind.Array) return byCode;

          foreach (var e in events.EnumerateArray()) {
              var code = TryInt(e, "code") ?? 0;
              var name = TryString(e, "name") ?? TryString(e, "displayName");
              if (code <= 0 || string.IsNullOrWhiteSpace(name)) continue;
              if (byCode.ContainsKey(code)) throw new InvalidOperationException($"Duplicate event code in JSON: {code}");

              var id = await _dal.BlueprintWrite.InsertEventAsync(defVersionId, name!, code, load);
              byCode[code] = new EventDef { Id = id, Code = code, Name = N(name!), DisplayName = name! };
          }

          return byCode;
      }

      private async Task<Dictionary<string, StateDef>> ImportStatesAsync(long defVersionId, JsonElement root, Dictionary<string, int> categoryMap, Dictionary<int, EventDef> eventsByCode, DbExecutionLoad load) {
          var map = new Dictionary<string, StateDef>(StringComparer.OrdinalIgnoreCase);
          if (!root.TryGetProperty("states", out var states) || states.ValueKind != JsonValueKind.Array) return map;

          foreach (var s in states.EnumerateArray()) {
              var name = TryString(s, "name") ?? TryString(s, "displayName");
              if (string.IsNullOrWhiteSpace(name)) continue;

              var key = N(name!);
              if (map.ContainsKey(key)) throw new InvalidOperationException($"Duplicate state name in JSON: {name}");

              var flags = (uint)(TryInt(s, "flags") ?? 0);
              if (TryBool(s, "is_initial") == true) flags |= (uint)LifeCycleStateFlag.IsInitial;
              if (TryBool(s, "is_final") == true) flags |= (uint)LifeCycleStateFlag.IsFinal;

              var timeoutMinutes = ParseTimeoutMinutes(s);
              var timeoutMode = ParseTimeoutMode(s);

              long timeoutEventId = 0;
              var timeoutEventCode = TryInt(s, "timeout_event") ?? TryInt(s, "timeoutEventCode");
              if (timeoutEventCode.HasValue && eventsByCode.TryGetValue(timeoutEventCode.Value, out var tev)) timeoutEventId = tev.Id;

              var catName = TryString(s, "category");
              var catId = (!string.IsNullOrWhiteSpace(catName) && categoryMap.TryGetValue(N(catName!), out var cid)) ? cid : 0;

              var id = await _dal.BlueprintWrite.InsertStateAsync(defVersionId, catId, name!, flags, timeoutMinutes, (uint)timeoutEventId, timeoutMode, load);

              map[key] = new StateDef {
                  Id = id,
                  Name = key,
                  DisplayName = name!,
                  Flags = flags,
                  TimeoutMinutes = timeoutMinutes,
                  TimeoutEventId = timeoutEventId,
                  IsInitial = (flags & (uint)LifeCycleStateFlag.IsInitial) != 0
              };
          }

          return map;
      }

      private async Task ImportTransitionsAsync(long defVersionId, JsonElement root, Dictionary<string, StateDef> statesByName, Dictionary<int, EventDef> eventsByCode, DbExecutionLoad load) {
          if (!root.TryGetProperty("transitions", out var trans) || trans.ValueKind != JsonValueKind.Array) return;

          foreach (var t in trans.EnumerateArray()) {
              var fromName = TryString(t, "from") ?? TryString(t, "fromState");
              var toName = TryString(t, "to") ?? TryString(t, "toState");
              var evCode = TryInt(t, "event") ?? TryInt(t, "eventCode");
              if (string.IsNullOrWhiteSpace(fromName) || string.IsNullOrWhiteSpace(toName) || !evCode.HasValue) continue;

              if (!statesByName.TryGetValue(N(fromName!), out var from)) throw new InvalidOperationException($"Transition from-state not found: {fromName}");
              if (!statesByName.TryGetValue(N(toName!), out var to)) throw new InvalidOperationException($"Transition to-state not found: {toName}");
              if (!eventsByCode.TryGetValue(evCode.Value, out var ev)) throw new InvalidOperationException($"Transition event code not found: {evCode}");

              var flags = (uint)(TryInt(t, "flags") ?? 0);
              await _dal.BlueprintWrite.InsertTransitionAsync(defVersionId, from.Id, to.Id, ev.Id, load);
          }
      }

      private static int? ParseTimeoutMinutes(JsonElement stateNode) {
          var tm = TryInt(stateNode, "timeout_minutes") ?? TryInt(stateNode, "timeoutMinutes");
          if (tm.HasValue) return tm;

          var dur = TryString(stateNode, "timeout");
          if (string.IsNullOrWhiteSpace(dur)) return null;

          var ts = XmlConvert.ToTimeSpan(dur!);
          var mins = (int)Math.Ceiling(ts.TotalMinutes);
          return mins <= 0 ? null : mins;
      }

      private static int ParseTimeoutMode(JsonElement stateNode) {
          var n = TryInt(stateNode, "timeout_mode") ?? TryInt(stateNode, "timeoutMode");
          if (n.HasValue) return n.Value;

          var s = TryString(stateNode, "timeout_mode") ?? TryString(stateNode, "timeoutMode");
          if (string.IsNullOrWhiteSpace(s)) return 0;
          return string.Equals(s.Trim(), "repeat", StringComparison.OrdinalIgnoreCase) ? 1 : 0;
      }

      private static string N(string s) => (s ?? string.Empty).Trim().ToLowerInvariant();

      private static string? ReqString(JsonElement e, string prop) => TryString(e, prop);

      private static string? TryString(JsonElement e, string prop) {
          if (!e.TryGetProperty(prop, out var v)) return null;
          return v.ValueKind == JsonValueKind.String ? v.GetString() : v.ToString();
      }

      private static int? TryInt(JsonElement e, string prop) {
          if (!e.TryGetProperty(prop, out var v)) return null;
          if (v.ValueKind == JsonValueKind.Number && v.TryGetInt32(out var i)) return i;
          if (v.ValueKind == JsonValueKind.String && int.TryParse(v.GetString(), out var j)) return j;
          return null;
      }

      private static bool? TryBool(JsonElement e, string prop) {
          if (!e.TryGetProperty(prop, out var v)) return null;
          if (v.ValueKind == JsonValueKind.True) return true;
          if (v.ValueKind == JsonValueKind.False) return false;
          if (v.ValueKind == JsonValueKind.String && bool.TryParse(v.GetString(), out var b)) return b;
          return null;
      }

      private static string Hash48(string input) {
          using var sha = SHA256.Create();
          var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input ?? string.Empty));
          var hex = BitConverter.ToString(bytes).Replace("-", "").ToLowerInvariant();
          return hex.Length <= 48 ? hex : hex.Substring(0, 48);
      }
  }

  internal sealed class BlueprintManager : IBlueprintManager {
    private readonly IWorkFlowDAL _dal;
    private readonly ConcurrentDictionary<string, Lazy<Task<DbRow>>> _latestDefVersion = new();
    private readonly ConcurrentDictionary<long, Lazy<Task<LifeCycleBlueprint>>> _blueprintsByVer = new();

    public BlueprintManager(IWorkFlowDAL dal) { _dal = dal ?? throw new ArgumentNullException(nameof(dal)); }

    public Task<DbRow> GetLatestDefVersionAsync(int envCode, string defName, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        var key = $"{envCode}:{(defName ?? string.Empty).Trim().ToLowerInvariant()}";
        var lazy = _latestDefVersion.GetOrAdd(key, _ => new Lazy<Task<DbRow>>(() => LoadLatestDefVersionAsync(envCode, defName)));
        return AwaitCachedAsync(_latestDefVersion, key, lazy.Value, ct);
    }

    public async Task<DbRow> GetDefVersionByIdAsync(long defVersionId, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        var row = await _dal.Blueprint.GetDefVersionByIdAsync(defVersionId, DbExecutionLoad.None);
        if (row == null) throw new InvalidOperationException($"def_version not found. id={defVersionId}");
        return row;
    }

    public async Task<LifeCycleBlueprint> GetBlueprintLatestAsync(int envCode, string defName, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        var dv = await GetLatestDefVersionAsync(envCode, defName, ct);
        return await GetBlueprintByVersionIdAsync(dv.GetLong("id"), ct);
    }

    public Task<LifeCycleBlueprint> GetBlueprintByVersionIdAsync(long defVersionId, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        var lazy = _blueprintsByVer.GetOrAdd(defVersionId, _ => new Lazy<Task<LifeCycleBlueprint>>(() => BuildBlueprintAsync(defVersionId)));
        return AwaitCachedAsync(_blueprintsByVer, defVersionId, lazy.Value, ct);
    }

    public void Clear() { _latestDefVersion.Clear(); _blueprintsByVer.Clear(); }

    public void Invalidate(int envCode, string defName) { _latestDefVersion.TryRemove($"{envCode}:{(defName ?? string.Empty).Trim().ToLowerInvariant()}", out _); }

    public void Invalidate(long defVersionId) { _blueprintsByVer.TryRemove(defVersionId, out _); }

    private async Task<DbRow> LoadLatestDefVersionAsync(int envCode, string defName) {
        var row = await _dal.Blueprint.GetLatestDefVersionByEnvCodeAndDefNameAsync(envCode, defName, DbExecutionLoad.None);
        if (row == null) throw new InvalidOperationException($"def_version not found. env={envCode}, def={defName}");
        return row;
    }

    private async Task<LifeCycleBlueprint> BuildBlueprintAsync(long defVersionId) {
        var dv = await _dal.Blueprint.GetDefVersionByIdAsync(defVersionId, DbExecutionLoad.None);
        if (dv == null) throw new InvalidOperationException($"def_version not found. id={defVersionId}");

        var bp = new LifeCycleBlueprint { DefVersionId = defVersionId, DefinitionId = dv.GetLong("parent"), EnvCode = dv.GetInt("env_code"), DefName = dv.GetString("def_name") ?? dv.GetString("name") ?? "unknown" };

        var stateRows = await _dal.Blueprint.ListStatesAsync(defVersionId, DbExecutionLoad.None);
        var eventRows = await _dal.Blueprint.ListEventsAsync(defVersionId, DbExecutionLoad.None);
        var transRows = await _dal.Blueprint.ListTransitionsAsync(defVersionId, DbExecutionLoad.None);

        var statesById = new Dictionary<long, StateDef>();
        long initialStateId = 0;

        foreach (var r in stateRows) {
            var flags = r.Get<uint>("flags");
            var isInitial = (flags & (uint)LifeCycleStateFlag.IsInitial) != 0;
            var st = new StateDef { Id = r.GetInt("id"), Name = r.GetString("name") ?? "", DisplayName = r.GetString("display_name") ?? r.GetString("name") ?? "", Flags = flags, TimeoutMinutes = r.GetNullableInt("timeout_minutes"), TimeoutEventId = r.GetNullableLong("timeout_event"), IsInitial = isInitial };
            if (statesById.ContainsKey(st.Id)) throw new InvalidOperationException($"Duplicate state id in DB rows. id={st.Id}");
            statesById[st.Id] = st;
            if (isInitial) { if (initialStateId != 0) throw new InvalidOperationException($"Multiple initial states detected. defVersionId={defVersionId}"); initialStateId = st.Id; }
        }

        if (initialStateId == 0 && statesById.Count > 0) initialStateId = statesById.Values.First().Id; // keep fallback if you want; otherwise throw

        var eventsById = new Dictionary<long, EventDef>();
        var eventsByName = new Dictionary<string, EventDef>(StringComparer.OrdinalIgnoreCase);
        var eventsByCode = new Dictionary<int, EventDef>();

        foreach (var r in eventRows) {
            var ev = new EventDef { Id = r.GetInt("id"), Code = r.GetInt("code"), Name = r.GetString("name") ?? "", DisplayName = r.GetString("display_name") ?? r.GetString("name") ?? "" };
            if (eventsById.ContainsKey(ev.Id)) throw new InvalidOperationException($"Duplicate event id in DB rows. id={ev.Id}");
            eventsById[ev.Id] = ev;
            if (!string.IsNullOrWhiteSpace(ev.Name)) eventsByName[ev.Name.Trim().ToLowerInvariant()] = ev;
            if (eventsByCode.ContainsKey(ev.Code)) throw new InvalidOperationException($"Duplicate event code in DB rows. code={ev.Code}");
            eventsByCode[ev.Code] = ev;
        }

        var transitions = new Dictionary<(long fromStateId, int eventId), TransitionDef>();
        foreach (var r in transRows) {
            var fromId = r.GetLong("from_state");
            var toId = r.GetLong("to_state");
            var evId = r.GetInt("event");
            var key = (fromId, evId);
            if (transitions.ContainsKey(key)) throw new InvalidOperationException($"Duplicate transition detected. defVersionId={defVersionId}, from={fromId}, event={evId}");
            transitions[key] = new TransitionDef { FromStateId = fromId, ToStateId = toId, EventId = evId, Flags = r.Get<uint>("flags") };
        }

        bp.StatesById = statesById;
        bp.EventsById = eventsById;
        bp.EventsByName = eventsByName;
        bp.EventsByCode = eventsByCode;
        bp.Transitions = transitions.ToDictionary(k => Tuple.Create(k.Key.fromStateId, k.Key.eventId), v => v.Value); // if your blueprint type requires Tuple keys
        bp.InitialStateId = initialStateId;

        return bp;
    }

    private static async Task<T> AwaitCachedAsync<TKey, T>(ConcurrentDictionary<TKey, Lazy<Task<T>>> dict, TKey key, Task<T> task, CancellationToken ct) {
        try { return await task.WaitAsync(ct); } catch { dict.TryRemove(key, out _); throw; }
    }
}

 internal sealed class LifeCycleMonitor : ILifeCycleMonitor {
     private readonly TimeSpan _interval;
     private readonly Func<CancellationToken, Task> _runOnce;
     private readonly Func<Exception, CancellationToken, Task>? _onError;

     private PeriodicTimer? _timer;
     private CancellationTokenSource? _cts;
     private Task? _loop;
     private int _running;
     private int _runGate;

     public bool IsRunning => Volatile.Read(ref _running) == 1;

     public LifeCycleMonitor(TimeSpan interval, Func<CancellationToken, Task> runOnce, Func<Exception, CancellationToken, Task>? onError = null) {
         if (interval <= TimeSpan.Zero) throw new ArgumentOutOfRangeException(nameof(interval));
         _interval = interval;
         _runOnce = runOnce ?? throw new ArgumentNullException(nameof(runOnce));
         _onError = onError;
     }

     public Task StartAsync(CancellationToken ct = default) {
         ct.ThrowIfCancellationRequested();
         if (Interlocked.CompareExchange(ref _running, 1, 0) != 0) return Task.CompletedTask;

         _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
         _timer = new PeriodicTimer(_interval);
         _loop = LoopAsync(_cts.Token);
         return Task.CompletedTask;
     }

     public async Task StopAsync(CancellationToken ct = default) {
         ct.ThrowIfCancellationRequested();
         if (Interlocked.CompareExchange(ref _running, 0, 1) != 1) return;

         try { _cts?.Cancel(); } catch { }
         var loop = _loop;
         if (loop != null) await loop;

         _timer?.Dispose();
         _timer = null;
         _cts?.Dispose();
         _cts = null;
         _loop = null;
         Interlocked.Exchange(ref _runGate, 0);
     }

     public async Task RunOnceAsync(CancellationToken ct = default) {
         ct.ThrowIfCancellationRequested();
         if (Interlocked.CompareExchange(ref _runGate, 1, 0) != 0) return;

         try {
             await _runOnce(ct);
         } catch (OperationCanceledException) when (ct.IsCancellationRequested) {
             throw;
         } catch (Exception ex) {
             if (_onError != null) await _onError(ex, ct);
         } finally {
             Interlocked.Exchange(ref _runGate, 0);
         }
     }

     private async Task LoopAsync(CancellationToken ct) {
         try {
             while (!ct.IsCancellationRequested && _timer != null) {
                 if (!await _timer.WaitForNextTickAsync(ct)) break;
                 await RunOnceAsync(ct);
             }
         } catch (OperationCanceledException) when (ct.IsCancellationRequested) {
             // expected on stop
         } catch (Exception ex) {
             if (_onError != null) await _onError(ex, ct);
         }
     }

     public async ValueTask DisposeAsync() { await StopAsync(CancellationToken.None); }
 }

  internal sealed class PolicyEnforcer : IPolicyEnforcer {
     private readonly IWorkFlowDAL _dal;

     public PolicyEnforcer(IWorkFlowDAL dal) { _dal = dal ?? throw new ArgumentNullException(nameof(dal)); }

     public async Task<PolicyResolution> ResolvePolicyAsync(LifeCycleBlueprint bp, DbRow instance, ApplyTransitionResult applied, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         var pr = new PolicyResolution();
         if (!applied.Applied) return pr;

         var pol = await _dal.Blueprint.GetPolicyForStateAsync(bp.DefinitionId, applied.ToStateId, load);
         if (pol == null) return pr;

         pr.PolicyId = pol.GetNullableLong("id");
         pr.PolicyHash = pol.GetString("hash");
         pr.PolicyJson = pol.GetString("content");
         return pr;
     }

     public async Task<IReadOnlyList<ILifeCycleHookEmission>> EmitHooksAsync(LifeCycleBlueprint bp, DbRow instance, ApplyTransitionResult applied, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         if (!applied.Applied) return Array.Empty<ILifeCycleHookEmission>();

         var pol = await _dal.Blueprint.GetPolicyForStateAsync(bp.DefinitionId, applied.ToStateId, load);
         var policyJson = pol?.GetString("content");
         if (string.IsNullOrWhiteSpace(policyJson)) return Array.Empty<ILifeCycleHookEmission>();

         if (!bp.StatesById.TryGetValue(applied.ToStateId, out var toState)) return Array.Empty<ILifeCycleHookEmission>();
         bp.EventsById.TryGetValue(applied.EventId, out var viaEvent);

         var instanceId = instance.GetLong("id");
         var emissions = new List<ILifeCycleHookEmission>();

         using var doc = JsonDocument.Parse(policyJson);
         if (!doc.RootElement.TryGetProperty("routes", out var routes) || routes.ValueKind != JsonValueKind.Array) return Array.Empty<ILifeCycleHookEmission>();

         foreach (var route in routes.EnumerateArray()) {
             load.Ct.ThrowIfCancellationRequested();

             var routeState = TryGetString(route, "state");
             if (string.IsNullOrWhiteSpace(routeState)) continue;

             if (!IsStateMatch(routeState!, toState)) continue;

             if (route.TryGetProperty("via", out var viaEl) && viaEl.ValueKind != JsonValueKind.Null && viaEl.ValueKind != JsonValueKind.Undefined) {
                 if (viaEvent == null) continue;
                 var viaCode = TryGetInt(viaEl);
                 if (!viaCode.HasValue || viaCode.Value != viaEvent.Code) continue;
             }

             if (!route.TryGetProperty("emit", out var emitEl) || emitEl.ValueKind != JsonValueKind.Array) continue;

             foreach (var e in emitEl.EnumerateArray()) {
                 load.Ct.ThrowIfCancellationRequested();

                 var hookCode = TryGetString(e, "event");
                 if (string.IsNullOrWhiteSpace(hookCode)) continue;

                 var hookId = await _dal.Hook.UpsertByKeyReturnIdAsync(instanceId, applied.ToStateId, applied.EventId, true, hookCode!, load);

                 var (onSuccess, onFailure) = ReadCompletionEvents(e);
                 var notBefore = ReadDateTimeOffset(e, "notBefore");
                 var deadline = ReadDateTimeOffset(e, "deadline");
                 var payload = ReadPayload(e);

                 emissions.Add(new LifeCycleHookEmission {
                     HookId = hookId,
                     StateId = applied.ToStateId,
                     OnEntry = true,
                     HookCode = hookCode!,
                     OnSuccessEvent = onSuccess,
                     OnFailureEvent = onFailure,
                     NotBefore = notBefore,
                     Deadline = deadline,
                     Payload = payload
                 });
             }
         }

         return emissions;
     }

     private static bool IsStateMatch(string routeState, StateDef toState) {
         if (string.Equals(routeState, toState.Name, StringComparison.OrdinalIgnoreCase)) return true;
         if (!string.IsNullOrWhiteSpace(toState.DisplayName) && string.Equals(routeState, toState.DisplayName, StringComparison.OrdinalIgnoreCase)) return true;
         return false;
     }

     private static (string? onSuccess, string? onFailure) ReadCompletionEvents(JsonElement emitObj) {
         if (!emitObj.TryGetProperty("complete", out var compEl) || compEl.ValueKind != JsonValueKind.Object) return (null, null);
         string? onSuccess = null;
         string? onFailure = null;
         if (compEl.TryGetProperty("success", out var sEl)) onSuccess = sEl.ValueKind == JsonValueKind.String ? sEl.GetString() : sEl.ToString();
         if (compEl.TryGetProperty("failure", out var fEl)) onFailure = fEl.ValueKind == JsonValueKind.String ? fEl.GetString() : fEl.ToString();
         return (onSuccess, onFailure);
     }

     private static DateTimeOffset? ReadDateTimeOffset(JsonElement obj, string prop) {
         if (!obj.TryGetProperty(prop, out var el) || el.ValueKind != JsonValueKind.String) return null;
         return DateTimeOffset.TryParse(el.GetString(), out var dt) ? dt : null;
     }

     private static IReadOnlyDictionary<string, object?>? ReadPayload(JsonElement emitObj) {
         if (!emitObj.TryGetProperty("payload", out var pEl) || pEl.ValueKind == JsonValueKind.Null || pEl.ValueKind == JsonValueKind.Undefined) return null;
         return JsonToDictionary(pEl);
     }

     private static string? TryGetString(JsonElement obj, string prop) {
         if (!obj.TryGetProperty(prop, out var el)) return null;
         return el.ValueKind == JsonValueKind.String ? el.GetString() : el.ToString();
     }

     private static int? TryGetInt(JsonElement el) {
         if (el.ValueKind == JsonValueKind.Number && el.TryGetInt32(out var i)) return i;
         if (el.ValueKind == JsonValueKind.String && int.TryParse(el.GetString(), out var j)) return j;
         return null;
     }

     private static IReadOnlyDictionary<string, object?> JsonToDictionary(JsonElement el) {
         if (el.ValueKind == JsonValueKind.Object) {
             var dict = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
             foreach (var p in el.EnumerateObject()) dict[p.Name] = JsonToObject(p.Value);
             return dict;
         }
         return new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase) { ["value"] = JsonToObject(el) };
     }

     private static object? JsonToObject(JsonElement el) {
         switch (el.ValueKind) {
             case JsonValueKind.Null:
             case JsonValueKind.Undefined: return null;
             case JsonValueKind.String: return el.GetString();
             case JsonValueKind.Number:
             if (el.TryGetInt64(out var l)) return l;
             if (el.TryGetDouble(out var d)) return d;
             return el.ToString();
             case JsonValueKind.True: return true;
             case JsonValueKind.False: return false;
             case JsonValueKind.Array:
             var list = new List<object?>();
             foreach (var x in el.EnumerateArray()) list.Add(JsonToObject(x));
             return list;
             case JsonValueKind.Object:
             var dict = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
             foreach (var p in el.EnumerateObject()) dict[p.Name] = JsonToObject(p.Value);
             return dict;
             default: return el.ToString();
         }
     }
 }

  internal sealed class RuntimeEngine : IRuntimeEngine {
     private readonly IWorkFlowDAL _dal;

     public RuntimeEngine(IWorkFlowDAL dal) { _dal = dal ?? throw new ArgumentNullException(nameof(dal)); }

     public async Task<long> UpsertAsync(RuntimeUpsertRequest req, CancellationToken ct = default) {
         ct.ThrowIfCancellationRequested();

         var transaction = _dal.CreateNewTransaction();
         using var tx = transaction.Begin(false);
         var load = new DbExecutionLoad(ct, transaction);
         var committed = false;

         try {
             var instanceId = await _dal.Instance.GetIdByGuidAsync(req.InstanceGuid, load);
             if (!instanceId.HasValue || instanceId.Value <= 0) throw new InvalidOperationException($"Instance not found: {req.InstanceGuid}");

             var runtimeId = await _dal.Runtime.UpsertByKeyReturnIdAsync(instanceId.Value, req.ActivityId, req.StateId, req.ActorId, req.StatusId, req.LcId, req.Frozen, load);

             var dataJson = req.Data == null ? null : JsonSerializer.Serialize(req.Data);
             var payloadJson = req.Payload == null ? null : JsonSerializer.Serialize(req.Payload);
             await _dal.RuntimeData.UpsertAsync(runtimeId, dataJson, payloadJson, load);

             tx.Commit();
             committed = true;
             return runtimeId;
         } catch {
             if (!committed) tx.Rollback();
             throw;
         }
     }

     public Task<int> SetStatusAsync(long runtimeId, long statusId, CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); return _dal.Runtime.SetStatusAsync(runtimeId, statusId, new DbExecutionLoad(ct)); }

     public Task<int> SetFrozenAsync(long runtimeId, bool frozen, CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); return _dal.Runtime.SetFrozenAsync(runtimeId, frozen, new DbExecutionLoad(ct)); }

     public Task<int> SetLcIdAsync(long runtimeId, long lcId, CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); return _dal.Runtime.SetLcIdAsync(runtimeId, lcId, new DbExecutionLoad(ct)); }

     public async Task<long> EnsureActivityAsync(string displayName, CancellationToken ct = default) {
         ct.ThrowIfCancellationRequested();
         var load = new DbExecutionLoad(ct);
         var row = await _dal.Activity.GetByNameAsync(displayName, load);
         return row != null ? row.GetLong("id") : await _dal.Activity.InsertAsync(displayName, load);
     }

     public async Task<long> EnsureActivityStatusAsync(string displayName, CancellationToken ct = default) {
         ct.ThrowIfCancellationRequested();
         var load = new DbExecutionLoad(ct);
         var row = await _dal.ActivityStatus.GetByNameAsync(displayName, load);
         return row != null ? row.GetLong("id") : await _dal.ActivityStatus.InsertAsync(displayName, load);
     }
 }

  internal sealed class StateMachine : IStateMachine {
     private readonly IWorkFlowDAL _dal;
     private readonly IBlueprintManager _bp;

     public StateMachine(IWorkFlowDAL dal, IBlueprintManager bp) { _dal = dal ?? throw new ArgumentNullException(nameof(dal)); _bp = bp ?? throw new ArgumentNullException(nameof(bp)); }

     public async Task<DbRow> EnsureInstanceAsync(long defVersionId, string externalRef, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         if (string.IsNullOrWhiteSpace(externalRef)) throw new ArgumentNullException(nameof(externalRef));

         var bp = await _bp.GetBlueprintByVersionIdAsync(defVersionId, load.Ct);
         var initStateId = bp.InitialStateId;

         var guid = await _dal.Instance.UpsertByKeyReturnGuidAsync(defVersionId, externalRef, initStateId, null, 0, (uint)LifeCycleInstanceFlag.Active, load);
         if (string.IsNullOrWhiteSpace(guid)) throw new InvalidOperationException("Instance upsert failed (guid null).");

         var row = await _dal.Instance.GetByGuidAsync(guid, load);
         if (row == null) throw new InvalidOperationException("Instance row missing after upsert.");
         return row;
     }

     public async Task<ApplyTransitionResult> ApplyTransitionAsync(LifeCycleBlueprint bp, DbRow instance, string eventName, string? requestId, string? actor, IReadOnlyDictionary<string, object?>? payload, DbExecutionLoad load = default) {
         load.Ct.ThrowIfCancellationRequested();
         if (bp == null) throw new ArgumentNullException(nameof(bp));
         if (instance == null) throw new ArgumentNullException(nameof(instance));
         if (string.IsNullOrWhiteSpace(eventName)) throw new ArgumentNullException(nameof(eventName));

         var res = new ApplyTransitionResult { Applied = false, EventName = string.Empty, Reason = string.Empty };

         var instanceId = instance.GetLong("id");
         var fromStateId = instance.GetLong("current_state");
         var ev = ResolveEvent(bp, eventName);

         res.FromStateId = fromStateId;
         res.EventId = ev?.Id ?? 0;
         res.EventCode = ev?.Code ?? 0;
         res.EventName = ev?.Name ?? string.Empty;

         if (ev == null) { res.Reason = "UnknownEvent"; res.ToStateId = fromStateId; return res; }

         if (!bp.Transitions.TryGetValue(Tuple.Create(fromStateId, ev.Id), out var t)) {
             res.Reason = "InvalidTransition";
             res.ToStateId = fromStateId;
             return res;
         }

         res.ToStateId = t.ToStateId;

         if (res.ToStateId == res.FromStateId) { res.Reason = "NoOpAlreadyInState"; return res; }

         var cas = await _dal.Instance.UpdateCurrentStateCasAsync(instanceId, fromStateId, res.ToStateId, ev.Id, load);
         if (cas != 1) { res.Reason = "ConcurrencyConflict"; return res; }

         var lcId = await _dal.LifeCycle.InsertAsync(instanceId, fromStateId, res.ToStateId, ev.Id, load);
         res.Applied = true;
         res.LifeCycleId = lcId;

         var store = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
         if (!string.IsNullOrWhiteSpace(requestId)) store["requestId"] = requestId;
         if (payload != null && payload.Count > 0) store["payload"] = payload;

         var payloadJson = store.Count == 0 ? null : JsonSerializer.Serialize(store);
         await _dal.LifeCycleData.UpsertAsync(lcId, actor, payloadJson, load);

         return res;
     }

     private static EventDef? ResolveEvent(LifeCycleBlueprint bp, string eventNameOrCode) {
         if (string.IsNullOrWhiteSpace(eventNameOrCode)) return null;
         var s = eventNameOrCode.Trim();
         if (int.TryParse(s, out var code) && bp.EventsByCode.TryGetValue(code, out var byCode)) return byCode;
         var key = s.ToLowerInvariant();
         if (bp.EventsByName.TryGetValue(key, out var byName)) return byName;
         return null;
     }
 }

 public sealed class WorkFlowEngine : IWorkFlowEngine {
    private readonly IWorkFlowDAL _dal;
    private readonly WorkFlowEngineOptions _opt;
    private readonly IReadOnlyList<long> _monitorConsumers;
    private readonly TimeSpan _ackPendingResendAfter = TimeSpan.FromSeconds(30);  // TODO: move to options
    private readonly TimeSpan _ackDeliveredResendAfter = TimeSpan.FromMinutes(5); // TODO: move to options

    public IStateMachine StateMachine { get; }
    public IBlueprintManager BlueprintManager { get; }
    public IBlueprintImporter BlueprintImporter { get; }
    public IPolicyEnforcer PolicyEnforcer { get; }
    public IAckManager AckManager { get; }
    public IRuntimeEngine Runtime { get; }
    public ILifeCycleMonitor Monitor { get; }
    public IWorkFlowDAL Dal { get { return _dal; } }

    public event Func<ILifeCycleEvent, Task>? EventRaised;
    public event Func<LifeCycleNotice, Task>? NoticeRaised;

    public WorkFlowEngine(IWorkFlowDAL dal, WorkFlowEngineOptions? options = null, IReadOnlyList<long>? monitorConsumers = null) {
        _dal = dal ?? throw new ArgumentNullException(nameof(dal));
        _opt = options ?? new WorkFlowEngineOptions();

        BlueprintManager = _opt.BlueprintManager ?? new BlueprintManager(_dal);

        // If you don't want engine to auto-create importer, pass it via options.
        BlueprintImporter = _opt.BlueprintImporter ?? throw new InvalidOperationException("BlueprintImporter is required (set WorkFlowEngineOptions.BlueprintImporter).");

        StateMachine = _opt.StateMachine ?? new StateMachine(_dal, BlueprintManager);
        PolicyEnforcer = _opt.PolicyEnforcer ?? new PolicyEnforcer(_dal);

        var tc = _opt.ResolveTransitionConsumers;
        var hc = _opt.ResolveHookConsumers;
        Func<long, long, CancellationToken, Task<IReadOnlyList<long>>> transitionConsumers = (dv, iid, ct) => Task.FromResult<IReadOnlyList<long>>(tc?.Invoke(dv, iid) ?? new long[] { _opt.DefaultConsumerId });
        Func<long, long, string, CancellationToken, Task<IReadOnlyList<long>>> hookConsumers = (dv, iid, code, ct) => Task.FromResult<IReadOnlyList<long>>(hc?.Invoke(dv, iid, code) ?? new long[] { _opt.DefaultConsumerId });

        AckManager = _opt.AckManager ?? new AckManager(_dal, transitionConsumers, hookConsumers);
        Runtime = _opt.RuntimeEngine ?? new RuntimeEngine(_dal);

        _monitorConsumers = monitorConsumers ?? new long[] { _opt.DefaultConsumerId };
        Monitor = new LifeCycleMonitor(_opt.MonitorInterval, ct => RunMonitorOnceAsync(ct), (ex, ct) => RaiseNoticeSafeAsync(LifeCycleNotice.Error("MONITOR_ERROR", "MONITOR_ERROR", ex.Message, ex), ct));
    }

    public Task StartAsync(CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); return Monitor.StartAsync(ct); }

    public Task StopAsync(CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); return Monitor.StopAsync(ct); }

    public async ValueTask DisposeAsync() { try { await StopAsync(CancellationToken.None); } catch { } await Monitor.DisposeAsync(); await _dal.DisposeAsync(); }

    public async Task<LifeCycleTriggerResult> TriggerAsync(LifeCycleTriggerRequest req, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        if (req == null) throw new ArgumentNullException(nameof(req));
        if (string.IsNullOrWhiteSpace(req.DefName)) throw new ArgumentNullException(nameof(req.DefName));
        if (string.IsNullOrWhiteSpace(req.ExternalRef)) throw new ArgumentNullException(nameof(req.ExternalRef));
        if (string.IsNullOrWhiteSpace(req.Event)) throw new ArgumentNullException(nameof(req.Event));

        // Blueprint read can be outside txn (pure read + cached).
        var bp = await BlueprintManager.GetBlueprintLatestAsync(req.EnvCode, req.DefName, ct);

        var transaction = _dal.CreateNewTransaction();
        using var tx = transaction.Begin(false);
        var load = new DbExecutionLoad(ct, transaction);
        var committed = false;

        var toDispatch = new List<ILifeCycleEvent>(8);
        var lcAckGuids = new List<string>(4);
        var hookAckGuids = new List<string>(8);

        DbRow instance = null!;
        ApplyTransitionResult applied = null!;
        PolicyResolution pr = null!;

        try {
            instance = await StateMachine.EnsureInstanceAsync(bp.DefVersionId, req.ExternalRef, load);
            applied = await StateMachine.ApplyTransitionAsync(bp, instance, req.Event, req.RequestId, req.Actor, req.Payload, load);

            var result = new LifeCycleTriggerResult {
                Applied = applied.Applied,
                InstanceGuid = instance.GetString("guid") ?? string.Empty,
                InstanceId = instance.GetLong("id"),
                LifeCycleId = applied.LifeCycleId,
                FromState = bp.StatesById.TryGetValue(applied.FromStateId, out var fs) ? (fs.Name ?? string.Empty) : string.Empty,
                ToState = bp.StatesById.TryGetValue(applied.ToStateId, out var ts) ? (ts.Name ?? string.Empty) : string.Empty,
                Reason = applied.Reason ?? string.Empty,
                LifecycleAckGuids = Array.Empty<string>(),
                HookAckGuids = Array.Empty<string>()
            };

            // Even if transition not applied, instance may have been created/ensured -> commit that.
            if (!applied.Applied) {
                transaction.Commit();
                committed = true;
                return result;
            }

            var instanceId = result.InstanceId;

            // Resolve policy (optional attach)
            pr = await PolicyEnforcer.ResolvePolicyAsync(bp, instance, applied, load) ?? new PolicyResolution();
            if (pr.PolicyId.HasValue) await _dal.Instance.SetPolicyAsync(instanceId, pr.PolicyId.Value, load);

            // Transition consumers
            var transitionConsumers = await AckManager.GetTransitionConsumersAsync(bp.DefVersionId, instanceId, ct);
            var normTransitionConsumers = NormalizeConsumers(transitionConsumers, _opt.DefaultConsumerId);

            // Create lifecycle ACK (one ack guid, multiple consumers) if required
            var lcAckGuid = string.Empty;
            if (req.AckRequired) {
                var ackRef = await AckManager.CreateLifecycleAckAsync(applied.LifeCycleId!.Value, normTransitionConsumers, (int)AckStatus.Pending, load);
                lcAckGuid = ackRef.AckGuid ?? string.Empty;
                lcAckGuids.Add(lcAckGuid);
            }

            // Build transition events (dispatch after commit)
            for (var i = 0; i < normTransitionConsumers.Count; i++) {
                var consumerId = normTransitionConsumers[i];
                toDispatch.Add(new LifeCycleTransitionEvent {
                    ConsumerId = consumerId,
                    InstanceId = instanceId,
                    DefinitionVersionId = bp.DefVersionId,
                    ExternalRef = req.ExternalRef,
                    RequestId = req.RequestId,
                    OccurredAt = DateTimeOffset.UtcNow,
                    AckGuid = lcAckGuid,
                    AckRequired = req.AckRequired,
                    Payload = req.Payload,
                    LifeCycleId = applied.LifeCycleId.Value,
                    FromStateId = applied.FromStateId,
                    ToStateId = applied.ToStateId,
                    EventId = applied.EventId,
                    EventCode = applied.EventCode,
                    EventName = applied.EventName ?? string.Empty,
                    PrevStateMeta = new Dictionary<string, object>(),
                    PolicyId = pr.PolicyId,
                    PolicyHash = pr.PolicyHash ?? string.Empty,
                    PolicyJson = pr.PolicyJson ?? string.Empty
                });
            }

            // Hooks (create hook rows in txn; dispatch after commit)
            var hookEmissions = await PolicyEnforcer.EmitHooksAsync(bp, instance, applied, load);
            for (var h = 0; h < hookEmissions.Count; h++) {
                var he = hookEmissions[h];
                var hookConsumers = await AckManager.GetHookConsumersAsync(bp.DefVersionId, instanceId, he.HookCode, ct);
                var normHookConsumers = NormalizeConsumers(hookConsumers, _opt.DefaultConsumerId);

                var hookAckGuid = string.Empty;
                if (req.AckRequired) {
                    var hookAck = await AckManager.CreateHookAckAsync(he.HookId, normHookConsumers, (int)AckStatus.Pending, load);
                    hookAckGuid = hookAck.AckGuid ?? string.Empty;
                    hookAckGuids.Add(hookAckGuid);
                }

                for (var i = 0; i < normHookConsumers.Count; i++) {
                    var consumerId = normHookConsumers[i];
                    toDispatch.Add(new LifeCycleHookEvent {
                        ConsumerId = consumerId,
                        InstanceId = instanceId,
                        DefinitionVersionId = bp.DefVersionId,
                        ExternalRef = req.ExternalRef,
                        RequestId = req.RequestId,
                        OccurredAt = DateTimeOffset.UtcNow,
                        AckGuid = hookAckGuid,
                        AckRequired = req.AckRequired,
                        Payload = he.Payload as IReadOnlyDictionary<string, object?>,
                        HookId = he.HookId,
                        StateId = he.StateId,
                        OnEntry = he.OnEntry,
                        HookCode = he.HookCode ?? string.Empty,
                        OnSuccessEvent = he.OnSuccessEvent ?? string.Empty,
                        OnFailureEvent = he.OnFailureEvent ?? string.Empty,
                        NotBefore = he.NotBefore,
                        Deadline = he.Deadline
                    });
                }
            }

            transaction.Commit();
            committed = true;

            // Dispatch AFTER commit (failures become notices; monitor will resend due to pending ACK rows).
            await DispatchEventsSafeAsync(toDispatch, ct);

            result.LifecycleAckGuids = lcAckGuids;
            result.HookAckGuids = hookAckGuids;
            return result;
        } catch (OperationCanceledException) when (ct.IsCancellationRequested) {
            if (!committed) { try { transaction.Rollback(); } catch { } }
            throw;
        } catch (Exception ex) {
            if (!committed) { try { transaction.Rollback(); } catch { } }
            await RaiseNoticeSafeAsync(LifeCycleNotice.Error("TRIGGER_ERROR", "TRIGGER_ERROR", ex.Message, ex), ct);
            throw;
        }
    }

    public async Task AckAsync(long consumerId, string ackGuid, AckOutcome outcome, string? message = null, DateTimeOffset? retryAt = null, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        if (consumerId <= 0) throw new ArgumentOutOfRangeException(nameof(consumerId));
        if (string.IsNullOrWhiteSpace(ackGuid)) throw new ArgumentNullException(nameof(ackGuid));
        await AckManager.AckAsync(consumerId, ackGuid, outcome, message, retryAt, new DbExecutionLoad(ct));
    }

    public Task ClearCacheAsync(CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); BlueprintManager.Clear(); return Task.CompletedTask; }

    public Task InvalidateAsync(int envCode, string defName, CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); BlueprintManager.Invalidate(envCode, defName); return Task.CompletedTask; }

    public Task InvalidateAsync(long defVersionId, CancellationToken ct = default) { ct.ThrowIfCancellationRequested(); BlueprintManager.Invalidate(defVersionId); return Task.CompletedTask; }

    public async Task RunMonitorOnceAsync(CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();

        // NOTE: stale-state / timeout-trigger monitor needs dedicated DAL queries; this run focuses on ACK resend.
        var nowUtc = DateTime.UtcNow;
        var pendingOlderThan = nowUtc.Subtract(_ackPendingResendAfter);
        var deliveredOlderThan = nowUtc.Subtract(_ackDeliveredResendAfter);

        for (var i = 0; i < _monitorConsumers.Count; i++) {
            ct.ThrowIfCancellationRequested();
            var consumerId = _monitorConsumers[i];

            await ResendDispatchKindAsync(consumerId, (int)AckStatus.Pending, pendingOlderThan, ct);
            await ResendDispatchKindAsync(consumerId, (int)AckStatus.Delivered, deliveredOlderThan, ct);
        }
    }

    private async Task ResendDispatchKindAsync(long consumerId, int ackStatus, DateTime olderThanUtc, CancellationToken ct) {
        ct.ThrowIfCancellationRequested();

        // Lifecycle
        var lc = await AckManager.ListPendingLifecycleDispatchAsync(consumerId, ackStatus, olderThanUtc, 0, _opt.MonitorPageSize, new DbExecutionLoad(ct));
        for (var i = 0; i < lc.Count; i++) {
            ct.ThrowIfCancellationRequested();
            var item = lc[i];

            await RaiseNoticeSafeAsync(LifeCycleNotice.Warn("ACK_RETRY", "ACK_RETRY", $"kind=lifecycle status={ackStatus} ack={item.AckGuid} consumer={item.ConsumerId} instance={item.Event.InstanceId}"), ct);
            await RaiseEventSafeAsync(item.Event, ct);
            await AckManager.MarkRetryAsync(item.AckId, item.ConsumerId, null, new DbExecutionLoad(ct));
        }

        // Hook
        var hk = await AckManager.ListPendingHookDispatchAsync(consumerId, ackStatus, olderThanUtc, 0, _opt.MonitorPageSize, new DbExecutionLoad(ct));
        for (var i = 0; i < hk.Count; i++) {
            ct.ThrowIfCancellationRequested();
            var item = hk[i];

            await RaiseNoticeSafeAsync(LifeCycleNotice.Warn("ACK_RETRY", "ACK_RETRY", $"kind=hook status={ackStatus} ack={item.AckGuid} consumer={item.ConsumerId} instance={item.Event.InstanceId}"), ct);
            await RaiseEventSafeAsync(item.Event, ct);
            await AckManager.MarkRetryAsync(item.AckId, item.ConsumerId, null, new DbExecutionLoad(ct));
        }
    }

    private async Task DispatchEventsSafeAsync(IReadOnlyList<ILifeCycleEvent> events, CancellationToken ct) {
        for (var i = 0; i < events.Count; i++) { ct.ThrowIfCancellationRequested(); await RaiseEventSafeAsync(events[i], ct); }
    }

    private async Task RaiseEventSafeAsync(ILifeCycleEvent e, CancellationToken ct) {
        ct.ThrowIfCancellationRequested();
        var h = EventRaised;
        if (h == null) return;
        try { await h.Invoke(e); } catch (Exception ex) { await RaiseNoticeSafeAsync(LifeCycleNotice.Error("EVENT_HANDLER_ERROR", "EVENT_HANDLER_ERROR", ex.Message, ex), ct); }
    }

    private async Task RaiseNoticeSafeAsync(LifeCycleNotice n, CancellationToken ct) {
        ct.ThrowIfCancellationRequested();
        var h = NoticeRaised;
        if (h == null) return;
        try { await h.Invoke(n); } catch { }
    }

    private static IReadOnlyList<long> NormalizeConsumers(IReadOnlyList<long>? consumers, long defaultConsumerId) {
        if (consumers == null || consumers.Count == 0) return new long[] { defaultConsumerId };
        var list = new List<long>(consumers.Count);
        for (var i = 0; i < consumers.Count; i++) { var c = consumers[i]; if (c > 0 && !list.Contains(c)) list.Add(c); }
        return list.Count == 0 ? new long[] { defaultConsumerId } : list;
    }
}