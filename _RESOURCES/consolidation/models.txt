
 public sealed class LifeCycleAckRef : ILifeCycleAckRef {
     public long AckId { get; set; }
     public string AckGuid { get; set; }
     public LifeCycleAckRef(long ackId, string ackGuid) { AckId = ackId; AckGuid = ackGuid ?? string.Empty; }
 }

     public sealed class LifeCycleHookEmission : ILifeCycleHookEmission {
        public long HookId { get; set; }
        public long StateId { get; set; }
        public bool OnEntry { get; set; }
        public string HookCode { get; set; }
        public string OnSuccessEvent { get; set; }
        public string OnFailureEvent { get; set; }
        public DateTimeOffset? NotBefore { get; set; }
        public DateTimeOffset? Deadline { get; set; }
        public IReadOnlyDictionary<string, object> Payload { get; set; }
    }

        public sealed class LifeCycleDispatchItem : ILifeCycleDispatchItem {
        public LifeCycleDispatchKind Kind { get; set; }
        public long AckId { get; set; }
        public string AckGuid { get; set; }
        public long ConsumerId { get; set; }
        public int AckStatus { get; set; }
        public int RetryCount { get; set; }
        public DateTime LastRetryUtc { get; set; }
        public ILifeCycleEvent Event { get; set; }
    }

 public sealed class EventDef {
    public long Id { get; set; }
    public int Code { get; set; }
    public string Name { get; set; }
    public string DisplayName { get; set; }
    public EventDef() { }
}

  public sealed class LifeCycleBlueprint {
      public long DefVersionId { get; set; }
      public long DefinitionId { get; set; }
      public int EnvCode { get; set; }
      public string DefName { get; set; }
      public IReadOnlyDictionary<long, StateDef> StatesById { get; set; }
      public IReadOnlyDictionary<long, EventDef> EventsById { get; set; }
      public IReadOnlyDictionary<string, EventDef> EventsByName { get; set; }
      public IReadOnlyDictionary<int, EventDef> EventsByCode { get; set; }
      public IReadOnlyDictionary<Tuple<long, long>, TransitionDef> Transitions { get; set; }
      public long InitialStateId { get; set; }
      public LifeCycleBlueprint() { }
  }

     public sealed class LifeCycleNotice {
    public LifeCycleNoticeKind Kind { get; }
    public string Code { get; }
    public string Message { get; }
    public Exception? Exception { get; }
    public DateTimeOffset OccurredAt { get; }

    public LifeCycleNotice(LifeCycleNoticeKind kind, string code, string message, Exception? exception = null) {
        Kind = kind;
        Code = code ?? string.Empty;
        Message = message ?? string.Empty;
        Exception = exception;
        OccurredAt = DateTimeOffset.UtcNow;
    }

    public static LifeCycleNotice Error(string code, string message, Exception ex) => new LifeCycleNotice(LifeCycleNoticeKind.Error, code, message, ex);
    public static LifeCycleNotice Warn(string code, string message) => new LifeCycleNotice(LifeCycleNoticeKind.Warning, code, message);
    public static LifeCycleNotice Info(string code, string message) => new LifeCycleNotice(LifeCycleNoticeKind.Info, code, message);
}

 public sealed class StateDef {
     public long Id { get; set; }
     public string Name { get; set; }
     public string DisplayName { get; set; }
     public uint Flags { get; set; }
     public int? TimeoutMinutes { get; set; }
     public long? TimeoutEventId { get; set; }
     public bool IsInitial { get; set; }
     public StateDef() { }
 }

  public sealed class TransitionDef {
     public long FromStateId { get; set; }
     public long ToStateId { get; set; }
     public long EventId { get; set; }
     public uint Flags { get; set; }
     public TransitionDef() { }
 }

  public abstract class LifeCycleEvent : ILifeCycleEvent {
     public abstract LifeCycleEventKind Kind { get; }

     public long ConsumerId { get; set; }
     public long InstanceId { get; set; }
     public long DefinitionVersionId { get; set; }
     public string ExternalRef { get; set; }
     public string? RequestId { get; set; }
     public DateTimeOffset OccurredAt { get; set; }
     public string AckGuid { get; set; }
     public bool AckRequired { get; set; }
     public IReadOnlyDictionary<string, object?>? Payload { get; set; }
 }

 public sealed class LifeCycleHookEvent : LifeCycleEvent, ILifeCycleHookEvent {
    public override LifeCycleEventKind Kind { get { return LifeCycleEventKind.Hook; } }
    public long HookId { get; set; }
    public long StateId { get; set; }
    public bool OnEntry { get; set; }
    public string HookCode { get; set; }
    public string OnSuccessEvent { get; set; }
    public string OnFailureEvent { get; set; }
    public DateTimeOffset? NotBefore { get; set; }
    public DateTimeOffset? Deadline { get; set; }
}

  public sealed class LifeCycleTransitionEvent : LifeCycleEvent, ILifeCycleTransitionEvent {
      public override LifeCycleEventKind Kind { get { return LifeCycleEventKind.Transition; } }
      public long LifeCycleId { get; set; }
      public long FromStateId { get; set; }
      public long ToStateId { get; set; }
      public long EventId { get; set; }
      public int EventCode { get; set; }
      public string EventName { get; set; }
      public IReadOnlyDictionary<string, object> PrevStateMeta { get; set; }
      public long? PolicyId { get; set; }
      public string PolicyHash { get; set; }
      public string PolicyJson { get; set; }
  }

  public sealed class ApplyTransitionResult {
     public bool Applied { get; set; }
     public long? LifeCycleId { get; set; }
     public long FromStateId { get; set; }
     public long ToStateId { get; set; }
     public long EventId { get; set; }
     public int EventCode { get; set; }
     public string EventName { get; set; }
     public string Reason { get; set; }
     public ApplyTransitionResult() { }
 }

  public sealed class LifeCycleTriggerRequest {
     public int EnvCode { get; set; }
     public string DefName { get; set; } = string.Empty;
     public string ExternalRef { get; set; } = string.Empty;
     public string EventName { get; set; } = string.Empty; // you can map name->code in blueprint if needed
     public string? RequestId { get; set; }
     public string? Actor { get; set; }
     public IReadOnlyDictionary<string, object?>? Payload { get; set; }
     public bool AckRequired { get; set; } = true;
     public DbExecutionLoad Load { get; set; } = default;
 }

  public sealed class LifeCycleTriggerResult {
     public bool Applied { get; set; }
     public string InstanceGuid { get; set; }
     public long InstanceId { get; set; }
     public long? LifeCycleId { get; set; }
     public string FromState { get; set; }
     public string ToState { get; set; }
     public string Reason { get; set; }
     public IReadOnlyList<string> LifecycleAckGuids { get; set; }
     public IReadOnlyList<string> HookAckGuids { get; set; }
     public LifeCycleTriggerResult() { }
 }

 public sealed class RuntimeUpsertRequest {
    public string InstanceGuid { get; set; }
    public long ActivityId { get; set; }
    public long StateId { get; set; }
    public string ActorId { get; set; }
    public long StatusId { get; set; }
    public long LcId { get; set; }
    public bool Frozen { get; set; }
    public object Data { get; set; }
    public object Payload { get; set; }
    public RuntimeUpsertRequest() { }
}

 public sealed class PolicyResolution {
     public long? PolicyId { get; set; }
     public string PolicyHash { get; set; }
     public string PolicyJson { get; set; }
     public PolicyResolution() { }
 }

    public sealed class WorkFlowEngineOptions {
       public TimeSpan MonitorInterval { get; set; } = TimeSpan.FromMinutes(2);
       public int MonitorPageSize { get; set; } = 200;
       public int MonitorMaxTimeoutTriggersPerRun { get; set; } = 200;

       // Ack consumer resolution (fallbacks)
       public long DefaultConsumerId { get; set; } = 1;
       public Func<long, long, IReadOnlyList<long>>? ResolveTransitionConsumers { get; set; } // (defVersionId, instanceId) => consumers
       public Func<long, long, string, IReadOnlyList<long>>? ResolveHookConsumers { get; set; } // (defVersionId, instanceId, hookCode) => consumers

       // Optional overrides (if you want to inject your own concrete implementations)
       public IBlueprintManager? BlueprintManager { get; set; }
       public IBlueprintImporter? BlueprintImporter { get; set; }
       public IStateMachine? StateMachine { get; set; }
       public IPolicyEnforcer? PolicyEnforcer { get; set; }
       public IAckManager? AckManager { get; set; }
       public IRuntimeEngine? RuntimeEngine { get; set; }
   }