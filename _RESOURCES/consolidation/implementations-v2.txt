// File: BlueprintManager.cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

public sealed class BlueprintManager : IBlueprintManager {
    private readonly IBlueprintReadDAL _bp;

    private readonly ConcurrentDictionary<long, LifeCycleBlueprint> _byVersionId = new();
    private readonly ConcurrentDictionary<string, long> _latestVersionIdByKey = new(); // "envCode|defName"

    public BlueprintManager(IBlueprintReadDAL bp) { _bp = bp ?? throw new ArgumentNullException(nameof(bp)); }

    public async Task<DbRow> GetLatestDefVersionAsync(int envCode, string defName, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        var row = await _bp.GetLatestDefVersionByEnvCodeAndDefNameAsync(envCode, defName);
        return row ?? throw new InvalidOperationException($"No def_version found for envCode={envCode}, defName='{defName}'.");
    }

    public async Task<DbRow> GetDefVersionByIdAsync(long defVersionId, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        var row = await _bp.GetDefVersionByIdAsync(defVersionId);
        return row ?? throw new InvalidOperationException($"No def_version found for id={defVersionId}.");
    }

    public async Task<LifeCycleBlueprint> GetBlueprintLatestAsync(int envCode, string defName, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        var key = MakeLatestKey(envCode, defName);

        if (_latestVersionIdByKey.TryGetValue(key, out var cachedVerId) && _byVersionId.TryGetValue(cachedVerId, out var cachedBp))
            return cachedBp;

        var defVer = await GetLatestDefVersionAsync(envCode, defName, ct);
        var defVersionId = GetLongAny(defVer, "id", "def_version_id", "defVersionId");
        if (defVersionId <= 0) throw new InvalidOperationException("Latest def_version row missing 'id'.");

        var bp = await GetBlueprintByVersionIdAsync(defVersionId, ct);
        _latestVersionIdByKey[key] = defVersionId;
        return bp;
    }

    public async Task<LifeCycleBlueprint> GetBlueprintByVersionIdAsync(long defVersionId, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        if (_byVersionId.TryGetValue(defVersionId, out var cached)) return cached;

        var defVer = await GetDefVersionByIdAsync(defVersionId, ct);

        var bp = await BuildBlueprintAsync(defVer, ct);
        _byVersionId[defVersionId] = bp;
        return bp;
    }

    public void Clear() {
        _byVersionId.Clear();
        _latestVersionIdByKey.Clear();
    }

    public void Invalidate(int envCode, string defName) {
        _latestVersionIdByKey.TryRemove(MakeLatestKey(envCode, defName), out _);
    }

    public void Invalidate(long defVersionId) {
        _byVersionId.TryRemove(defVersionId, out _);
    }

    private async Task<LifeCycleBlueprint> BuildBlueprintAsync(DbRow defVer, CancellationToken ct) {
        ct.ThrowIfCancellationRequested();

        var defVersionId = GetLongAny(defVer, "id");
        var definitionId = GetLongAny(defVer, "parent", "definition_id", "definitionId");

        var statesRows = await _bp.ListStatesAsync(defVersionId);
        var eventsRows = await _bp.ListEventsAsync(defVersionId);
        var transRows = await _bp.ListTransitionsAsync(defVersionId);

        var statesById = new Dictionary<long, StateDef>();
        foreach (var r in statesRows) {
            var id = GetLongAny(r, "id");
            var name = GetStringAny(r, "name") ?? string.Empty;
            var display = GetStringAny(r, "display_name", "displayName") ?? name;
            var flags = (uint)GetIntAny(r, "flags");
            var timeoutMinutes = GetNullableIntAny(r, "timeout_minutes", "timeoutMinutes");
            var timeoutEventId = GetNullableLongAny(r, "timeout_event", "timeoutEvent");

            var s = new StateDef {
                Id = id,
                Name = name,
                DisplayName = display,
                Flags = flags,
                TimeoutMinutes = timeoutMinutes,
                TimeoutEventId = timeoutEventId,
                IsInitial = (flags & (uint)LifeCycleStateFlag.IsInitial) != 0
            };
            statesById[id] = s;
        }

        var eventsById = new Dictionary<long, EventDef>();
        var eventsByName = new Dictionary<string, EventDef>(StringComparer.OrdinalIgnoreCase);
        var eventsByCode = new Dictionary<int, EventDef>();
        foreach (var r in eventsRows) {
            var id = GetLongAny(r, "id");
            var code = GetIntAny(r, "code");
            var name = GetStringAny(r, "name") ?? string.Empty;
            var display = GetStringAny(r, "display_name", "displayName") ?? name;

            var e = new EventDef { Id = id, Code = code, Name = name, DisplayName = display };
            eventsById[id] = e;
            if (!string.IsNullOrWhiteSpace(name)) eventsByName[name.Trim()] = e;
            if (code != 0) eventsByCode[code] = e;
        }

        var transitions = new Dictionary<Tuple<long, long>, TransitionDef>();
        foreach (var r in transRows) {
            var from = GetLongAny(r, "from_state", "fromStateId", "from_state_id");
            var to = GetLongAny(r, "to_state", "toStateId", "to_state_id");
            var ev = GetLongAny(r, "event", "eventId", "event_id");

            var t = new TransitionDef {
                FromStateId = from,
                ToStateId = to,
                EventId = ev,
                Flags = 0
            };
            transitions[Tuple.Create(from, ev)] = t;
        }

        var initialStateId = statesById.Values.FirstOrDefault(x => x.IsInitial)?.Id ?? 0;

        // EnvCode / DefName are set by caller (latest) in your own wiring if needed.
        return new LifeCycleBlueprint {
            DefVersionId = defVersionId,
            DefinitionId = definitionId,
            EnvCode = 0,
            DefName = string.Empty,
            StatesById = statesById,
            EventsById = eventsById,
            EventsByName = eventsByName,
            EventsByCode = eventsByCode,
            Transitions = transitions,
            InitialStateId = initialStateId
        };
    }

    private static string MakeLatestKey(int envCode, string defName) => $"{envCode}|{(defName ?? string.Empty).Trim().ToLowerInvariant()}";

    private static long GetLongAny(IDictionary<string, object> row, params string[] keys) {
        foreach (var k in keys) {
            var v = row.GetLong(k);
            if (v != 0) return v;
        }
        return 0;
    }

    private static long? GetNullableLongAny(IDictionary<string, object> row, params string[] keys) {
        foreach (var k in keys) {
            var v = row.GetNullableLong(k);
            if (v.HasValue) return v.Value;
        }
        return null;
    }

    private static int GetIntAny(IDictionary<string, object> row, params string[] keys) {
        foreach (var k in keys) {
            var v = row.GetInt(k);
            if (v != 0) return v;
        }
        return 0;
    }

    private static int? GetNullableIntAny(IDictionary<string, object> row, params string[] keys) {
        foreach (var k in keys) {
            var v = row.GetNullableInt(k);
            if (v.HasValue) return v.Value;
        }
        return null;
    }

    private static string? GetStringAny(IDictionary<string, object> row, params string[] keys) {
        foreach (var k in keys) {
            var v = row.GetString(k);
            if (!string.IsNullOrWhiteSpace(v)) return v;
        }
        return null;
    }
}


// File: StateMachine.cs
using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading.Tasks;

public sealed class StateMachine : IStateMachine {
    private readonly IInstanceDAL _instance;
    private readonly ILifeCycleDAL _lc;
    private readonly ILifeCycleDataDAL _lcData;

    public StateMachine(IInstanceDAL instance, ILifeCycleDAL lc, ILifeCycleDataDAL lcData) {
        _instance = instance ?? throw new ArgumentNullException(nameof(instance));
        _lc = lc ?? throw new ArgumentNullException(nameof(lc));
        _lcData = lcData ?? throw new ArgumentNullException(nameof(lcData));
    }

    public async Task<DbRow> EnsureInstanceAsync(long defVersionId, string externalRef, DbExecutionLoad load = default) {
        var initialStateId = 0L; // caller should upsert with correct state id; if not provided, DB may reject. This ensures "existence" only.
        var flags = (uint)LifeCycleInstanceFlag.Active;

        // NOTE: UpsertByKeyReturnGuidAsync needs currentStateId/policyId; call-site should prefer to pass initial state via bp.
        var guid = await _instance.UpsertByKeyReturnGuidAsync(defVersionId, externalRef, initialStateId, null, 0, flags, load);
        if (string.IsNullOrWhiteSpace(guid)) throw new InvalidOperationException("Instance upsert did not return guid.");

        var row = await _instance.GetByGuidAsync(guid, load);
        return row ?? throw new InvalidOperationException("Instance upsert returned guid but instance row not found.");
    }

    public async Task<ApplyTransitionResult> ApplyTransitionAsync(
        LifeCycleBlueprint bp,
        DbRow instance,
        string eventName,
        string? requestId,
        string? actor,
        IReadOnlyDictionary<string, object?>? payload,
        DbExecutionLoad load = default
    ) {
        if (bp == null) throw new ArgumentNullException(nameof(bp));
        if (instance == null) throw new ArgumentNullException(nameof(instance));
        if (string.IsNullOrWhiteSpace(eventName)) throw new ArgumentNullException(nameof(eventName));

        var instanceId = instance.GetLong("id");
        var fromStateId = instance.GetLong("current_state");
        if (instanceId <= 0) return Fail("Invalid instance row: missing id.");
        if (fromStateId <= 0) return Fail("Invalid instance row: missing current_state.");

        if (!bp.EventsByName.TryGetValue(eventName.Trim(), out var ev))
            return Fail($"Unknown event '{eventName}' for this definition.");

        var key = Tuple.Create(fromStateId, ev.Id);
        if (!bp.Transitions.TryGetValue(key, out var tr))
            return Fail($"No transition from stateId={fromStateId} via event='{eventName}'.");

        var toStateId = tr.ToStateId;

        var cas = await _instance.UpdateCurrentStateCasAsync(instanceId, fromStateId, toStateId, ev.Id, load);
        if (cas <= 0) return Fail("CAS failed: instance current_state changed (concurrent update).");

        var lcId = await _lc.InsertAsync(instanceId, fromStateId, toStateId, ev.Id, load);

        string? payloadJson = null;
        if (payload != null && payload.Count > 0) payloadJson = JsonSerializer.Serialize(payload);
        await _lcData.UpsertAsync(lcId, actor, payloadJson, load);

        return new ApplyTransitionResult {
            Applied = true,
            LifeCycleId = lcId,
            FromStateId = fromStateId,
            ToStateId = toStateId,
            EventId = ev.Id,
            EventCode = ev.Code,
            EventName = ev.Name ?? ev.DisplayName ?? eventName,
            Reason = "OK"
        };

        static ApplyTransitionResult Fail(string reason) => new ApplyTransitionResult {
            Applied = false,
            LifeCycleId = null,
            FromStateId = 0,
            ToStateId = 0,
            EventId = 0,
            EventCode = 0,
            EventName = string.Empty,
            Reason = reason
        };
    }
}
// File: PolicyEnforcer.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

public sealed class PolicyEnforcer : IPolicyEnforcer {
    private readonly IBlueprintReadDAL _bp;

    public PolicyEnforcer(IBlueprintReadDAL bp) { _bp = bp ?? throw new ArgumentNullException(nameof(bp)); }

    public async Task<PolicyResolution> ResolvePolicyAsync(LifeCycleBlueprint bp, DbRow instance, ApplyTransitionResult applied, DbExecutionLoad load = default) {
        if (bp == null) throw new ArgumentNullException(nameof(bp));
        if (applied == null) throw new ArgumentNullException(nameof(applied));
        if (!applied.Applied) return new PolicyResolution { PolicyId = null, PolicyHash = string.Empty, PolicyJson = string.Empty };

        var row = await _bp.GetPolicyForStateAsync(bp.DefinitionId, applied.ToStateId, load);
        if (row == null) return new PolicyResolution { PolicyId = null, PolicyHash = string.Empty, PolicyJson = string.Empty };

        var policyId = row.GetNullableLong("id") ?? row.GetNullableLong("policy_id");
        var hash = row.GetString("hash") ?? row.GetString("policy_hash") ?? string.Empty;
        var json = row.GetString("content") ?? row.GetString("policy_json") ?? string.Empty;

        return new PolicyResolution { PolicyId = policyId, PolicyHash = hash, PolicyJson = json };
    }

    public Task<IReadOnlyList<ILifeCycleHookEmission>> EmitHooksAsync(LifeCycleBlueprint bp, DbRow instance, ApplyTransitionResult applied, DbExecutionLoad load = default) {
        // v0.2: hook emission depends on your policy JSON grammar.
        // Keep this no-op unless you plug in a policy interpreter.
        IReadOnlyList<ILifeCycleHookEmission> empty = Array.Empty<ILifeCycleHookEmission>();
        return Task.FromResult(empty);
    }
}
// File: AckManager.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

public interface IAckConsumerResolver {
    Task<IReadOnlyList<long>> GetTransitionConsumersAsync(long defVersionId, long instanceId, CancellationToken ct = default);
    Task<IReadOnlyList<long>> GetHookConsumersAsync(long defVersionId, long instanceId, string hookCode, CancellationToken ct = default);
}

public sealed class AckManager : IAckManager {
    private readonly IAckDAL _ack;
    private readonly ILcAckDAL _lcAck;
    private readonly IHookAckDAL _hookAck;
    private readonly IAckConsumerDAL _ackConsumer;
    private readonly IAckDispatchDAL _dispatch;
    private readonly IAckConsumerResolver? _resolver;

    public AckManager(IAckDAL ack, ILcAckDAL lcAck, IHookAckDAL hookAck, IAckConsumerDAL ackConsumer, IAckDispatchDAL dispatch, IAckConsumerResolver? resolver = null) {
        _ack = ack ?? throw new ArgumentNullException(nameof(ack));
        _lcAck = lcAck ?? throw new ArgumentNullException(nameof(lcAck));
        _hookAck = hookAck ?? throw new ArgumentNullException(nameof(hookAck));
        _ackConsumer = ackConsumer ?? throw new ArgumentNullException(nameof(ackConsumer));
        _dispatch = dispatch ?? throw new ArgumentNullException(nameof(dispatch));
        _resolver = resolver;
    }

    public async Task<ILifeCycleAckRef> CreateLifecycleAckAsync(long lifecycleId, IReadOnlyList<long> consumerIds, int initialAckStatus, DbExecutionLoad load = default) {
        var existingAckId = await _lcAck.GetAckIdByLcIdAsync(lifecycleId, load);
        if (existingAckId.HasValue && existingAckId.Value > 0) {
            var a = await _ack.GetByIdAsync(existingAckId.Value, load) ?? throw new InvalidOperationException("lc_ack references missing ack row.");
            var guid = a.GetString("guid") ?? throw new InvalidOperationException("ack row missing guid.");
            await UpsertConsumersAsync(existingAckId.Value, consumerIds, initialAckStatus, load);
            return new LifeCycleAckRef(existingAckId.Value, guid);
        }

        var ackRow = await _ack.InsertReturnRowAsync(load) ?? throw new InvalidOperationException("Failed to insert ack.");
        var ackId = ackRow.GetLong("id");
        var ackGuid = ackRow.GetString("guid") ?? string.Empty;

        await _lcAck.AttachAsync(ackId, lifecycleId, load);
        await UpsertConsumersAsync(ackId, consumerIds, initialAckStatus, load);

        return new LifeCycleAckRef(ackId, ackGuid);
    }

    public async Task<ILifeCycleAckRef> CreateHookAckAsync(long hookId, IReadOnlyList<long> consumerIds, int initialAckStatus, DbExecutionLoad load = default) {
        var existingAckId = await _hookAck.GetAckIdByHookIdAsync(hookId, load);
        if (existingAckId.HasValue && existingAckId.Value > 0) {
            var a = await _ack.GetByIdAsync(existingAckId.Value, load) ?? throw new InvalidOperationException("hook_ack references missing ack row.");
            var guid = a.GetString("guid") ?? throw new InvalidOperationException("ack row missing guid.");
            await UpsertConsumersAsync(existingAckId.Value, consumerIds, initialAckStatus, load);
            return new LifeCycleAckRef(existingAckId.Value, guid);
        }

        var ackRow = await _ack.InsertReturnRowAsync(load) ?? throw new InvalidOperationException("Failed to insert ack.");
        var ackId = ackRow.GetLong("id");
        var ackGuid = ackRow.GetString("guid") ?? string.Empty;

        await _hookAck.AttachAsync(ackId, hookId, load);
        await UpsertConsumersAsync(ackId, consumerIds, initialAckStatus, load);

        return new LifeCycleAckRef(ackId, ackGuid);
    }

    public async Task AckAsync(long consumerId, string ackGuid, AckOutcome outcome, string? message = null, DateTimeOffset? retryAt = null, DbExecutionLoad load = default) {
        // NOTE: schema has no "message" or "retryAt" storage. We ignore them here.
        // RetryAt is not persisted (no column); MarkRetry uses "last_retry = now".
        var status = outcome switch {
            AckOutcome.Delivered => (int)AckStatus.Delivered,
            AckOutcome.Processed => (int)AckStatus.Processed,
            AckOutcome.Failed => (int)AckStatus.Failed,
            AckOutcome.Retry => (int)AckStatus.Pending,
            _ => (int)AckStatus.Pending
        };

        if (outcome == AckOutcome.Retry) {
            var ac = await _ackConsumer.GetByAckGuidAndConsumerAsync(ackGuid, consumerId, load);
            if (ac != null) {
                var ackId = ac.GetLong("ack_id");
                await _ackConsumer.SetStatusByGuidAsync(ackGuid, consumerId, status, load);
                if (ackId > 0) await _ackConsumer.MarkRetryAsync(ackId, consumerId, load);
                return;
            }
        }

        await _ackConsumer.SetStatusByGuidAsync(ackGuid, consumerId, status, load);
    }

    public Task MarkRetryAsync(long ackId, long consumerId, DateTimeOffset? retryAt = null, DbExecutionLoad load = default) {
        // retryAt cannot be persisted with current schema/DAL.
        return _ackConsumer.MarkRetryAsync(ackId, consumerId, load);
    }

    public Task SetStatusAsync(long ackId, long consumerId, int ackStatus, DbExecutionLoad load = default) => _ackConsumer.SetStatusAsync(ackId, consumerId, ackStatus, load);

    public async Task<IReadOnlyList<ILifeCycleDispatchItem>> ListPendingLifecycleDispatchAsync(long consumerId, int ackStatus, DateTime utcOlderThan, int skip, int take, DbExecutionLoad load = default) {
        var rows = await _dispatch.ListPendingLifecycleReadyPagedAsync(consumerId, ackStatus, utcOlderThan, skip, take, load);
        return rows.Select(r => MapLifecycleDispatch(r, consumerId)).ToList();
    }

    public async Task<IReadOnlyList<ILifeCycleDispatchItem>> ListPendingHookDispatchAsync(long consumerId, int ackStatus, DateTime utcOlderThan, int skip, int take, DbExecutionLoad load = default) {
        var rows = await _dispatch.ListPendingHookReadyPagedAsync(consumerId, ackStatus, utcOlderThan, skip, take, load);
        return rows.Select(r => MapHookDispatch(r, consumerId)).ToList();
    }

    public async Task<int> CountPendingLifecycleDispatchAsync(int ackStatus, DateTime utcOlderThan, DbExecutionLoad load = default) {
        var v = await _dispatch.CountPendingLifecycleReadyAsync(ackStatus, utcOlderThan, load);
        return v ?? 0;
    }

    public async Task<int> CountPendingHookDispatchAsync(int ackStatus, DateTime utcOlderThan, DbExecutionLoad load = default) {
        var v = await _dispatch.CountPendingHookReadyAsync(ackStatus, utcOlderThan, load);
        return v ?? 0;
    }

    public Task<IReadOnlyList<long>> GetTransitionConsumersAsync(long defVersionId, long instanceId, CancellationToken ct = default)
        => _resolver?.GetTransitionConsumersAsync(defVersionId, instanceId, ct) ?? Task.FromResult((IReadOnlyList<long>)Array.Empty<long>());

    public Task<IReadOnlyList<long>> GetHookConsumersAsync(long defVersionId, long instanceId, string hookCode, CancellationToken ct = default)
        => _resolver?.GetHookConsumersAsync(defVersionId, instanceId, hookCode, ct) ?? Task.FromResult((IReadOnlyList<long>)Array.Empty<long>());

    private async Task UpsertConsumersAsync(long ackId, IReadOnlyList<long> consumerIds, int status, DbExecutionLoad load) {
        if (consumerIds == null || consumerIds.Count == 0) return;
        foreach (var c in consumerIds.Distinct()) {
            if (c <= 0) continue;
            await _ackConsumer.UpsertByAckIdAndConsumerReturnIdAsync(ackId, c, status, load);
        }
    }

    private ILifeCycleDispatchItem MapLifecycleDispatch(DbRow r, long consumerId) {
        var ackId = GetLongAny(r, "ack_id", "ackId");
        var ackGuid = GetStringAny(r, "ack_guid", "guid", "ackGuid") ?? string.Empty;
        var status = GetIntAny(r, "status", "ack_status", "ackStatus");
        var retry = GetIntAny(r, "retry_count", "retryCount");
        var lastRetry = r.GetDateTime("last_retry") ?? DateTime.UtcNow;

        var instanceId = GetLongAny(r, "instance_id", "instanceId");
        var defVerId = GetLongAny(r, "def_version", "defVersionId", "definition_version_id");
        var externalRef = GetStringAny(r, "external_ref", "externalRef") ?? string.Empty;
        var requestId = GetStringAny(r, "request_id", "requestId");
        var occurredAt = r.GetDateTimeOffset("occurred_at") ?? new DateTimeOffset(r.GetDateTime("created") ?? DateTime.UtcNow);

        var lcId = GetLongAny(r, "lc_id", "lifecycle_id", "lifeCycleId");
        var fromStateId = GetLongAny(r, "from_state", "fromStateId", "from_state_id");
        var toStateId = GetLongAny(r, "to_state", "toStateId", "to_state_id");
        var eventId = GetLongAny(r, "event_id", "event", "eventId");
        var eventCode = GetIntAny(r, "event_code", "eventCode");
        var eventName = GetStringAny(r, "event_name", "eventName") ?? string.Empty;

        var ev = LifeCycleTransitionEvent.Create(
            consumerId, instanceId, defVerId, externalRef, requestId, occurredAt,
            ackRequired: true, ackGuid: ackGuid,
            lifeCycleId: lcId, fromStateId: fromStateId, toStateId: toStateId,
            eventId: eventId, eventCode: eventCode, eventName: eventName,
            payload: null, prevStateMeta: null, policy: null
        );

        return new LifeCycleDispatchItem {
            Kind = LifeCycleDispatchKind.Lifecycle,
            AckId = ackId,
            AckGuid = ackGuid,
            ConsumerId = consumerId,
            AckStatus = status,
            RetryCount = retry,
            LastRetryUtc = lastRetry,
            Event = ev
        };
    }

    private ILifeCycleDispatchItem MapHookDispatch(DbRow r, long consumerId) {
        var ackId = GetLongAny(r, "ack_id", "ackId");
        var ackGuid = GetStringAny(r, "ack_guid", "guid", "ackGuid") ?? string.Empty;
        var status = GetIntAny(r, "status", "ack_status", "ackStatus");
        var retry = GetIntAny(r, "retry_count", "retryCount");
        var lastRetry = r.GetDateTime("last_retry") ?? DateTime.UtcNow;

        var instanceId = GetLongAny(r, "instance_id", "instanceId");
        var defVerId = GetLongAny(r, "def_version", "defVersionId", "definition_version_id");
        var externalRef = GetStringAny(r, "external_ref", "externalRef") ?? string.Empty;
        var requestId = GetStringAny(r, "request_id", "requestId");
        var occurredAt = r.GetDateTimeOffset("occurred_at") ?? new DateTimeOffset(r.GetDateTime("created") ?? DateTime.UtcNow);

        var hookId = GetLongAny(r, "hook_id", "hookId");
        var stateId = GetLongAny(r, "state_id", "stateId");
        var onEntry = GetBoolAny(r, "on_entry", "onEntry");
        var hookCode = GetStringAny(r, "route", "hook_code", "hookCode") ?? string.Empty;

        var onSuccess = GetStringAny(r, "on_success_event", "onSuccessEvent");
        var onFailure = GetStringAny(r, "on_failure_event", "onFailureEvent");
        var notBefore = r.GetDateTimeOffset("not_before");
        var deadline = r.GetDateTimeOffset("deadline");

        var ev = LifeCycleHookEvent.Create(
            consumerId, instanceId, defVerId, externalRef, requestId, occurredAt,
            ackRequired: true, ackGuid: ackGuid,
            hookId: hookId, stateId: stateId, onEntry: onEntry, hookCode: hookCode,
            onSuccessEvent: onSuccess, onFailureEvent: onFailure,
            notBefore: notBefore, deadline: deadline,
            payload: null
        );

        return new LifeCycleDispatchItem {
            Kind = LifeCycleDispatchKind.Hook,
            AckId = ackId,
            AckGuid = ackGuid,
            ConsumerId = consumerId,
            AckStatus = status,
            RetryCount = retry,
            LastRetryUtc = lastRetry,
            Event = ev
        };
    }

    private static long GetLongAny(IDictionary<string, object> row, params string[] keys) { foreach (var k in keys) { var v = row.GetLong(k); if (v != 0) return v; } return 0; }
    private static int GetIntAny(IDictionary<string, object> row, params string[] keys) { foreach (var k in keys) { var v = row.GetInt(k); if (v != 0) return v; } return 0; }
    private static bool GetBoolAny(IDictionary<string, object> row, params string[] keys) { foreach (var k in keys) { var v = row.GetBool(k); if (v) return true; } return false; }
    private static string? GetStringAny(IDictionary<string, object> row, params string[] keys) { foreach (var k in keys) { var v = row.GetString(k); if (!string.IsNullOrWhiteSpace(v)) return v; } return null; }
}
// File: RuntimeEngine.cs
using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

public sealed class RuntimeEngine : IRuntimeEngine {
    private readonly IInstanceDAL _instance;
    private readonly IRuntimeDAL _runtime;
    private readonly IRuntimeDataDAL _runtimeData;

    public RuntimeEngine(IInstanceDAL instance, IRuntimeDAL runtime, IRuntimeDataDAL runtimeData) {
        _instance = instance ?? throw new ArgumentNullException(nameof(instance));
        _runtime = runtime ?? throw new ArgumentNullException(nameof(runtime));
        _runtimeData = runtimeData ?? throw new ArgumentNullException(nameof(runtimeData));
    }

    public async Task<long> UpsertAsync(RuntimeUpsertRequest req, DbExecutionLoad load = default, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        if (req == null) throw new ArgumentNullException(nameof(req));
        if (string.IsNullOrWhiteSpace(req.InstanceGuid)) throw new ArgumentNullException(nameof(req.InstanceGuid));
        if (string.IsNullOrWhiteSpace(req.ActorId)) throw new ArgumentNullException(nameof(req.ActorId));

        var instanceId = await _instance.GetIdByGuidAsync(req.InstanceGuid, load);
        if (!instanceId.HasValue || instanceId.Value <= 0) throw new InvalidOperationException("Instance not found by guid.");

        var runtimeId = await _runtime.UpsertByKeyReturnIdAsync(instanceId.Value, req.ActivityId, req.StateId, req.ActorId, req.StatusId, req.LcId, req.Frozen, load);

        string? dataJson = (req.Data != null && req.Data.Count > 0) ? JsonSerializer.Serialize(req.Data) : null;
        string? payloadJson = (req.Payload != null && req.Payload.Count > 0) ? JsonSerializer.Serialize(req.Payload) : null;

        await _runtimeData.UpsertAsync(runtimeId, dataJson, payloadJson, load);
        return runtimeId;
    }

    public Task<int> SetStatusAsync(long runtimeId, long statusId, DbExecutionLoad load = default, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        return _runtime.SetStatusAsync(runtimeId, statusId, load);
    }

    public Task<int> SetFrozenAsync(long runtimeId, bool frozen, DbExecutionLoad load = default, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        return _runtime.SetFrozenAsync(runtimeId, frozen, load);
    }

    public Task<int> SetLcIdAsync(long runtimeId, long lcId, DbExecutionLoad load = default, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        return _runtime.SetLcIdAsync(runtimeId, lcId, load);
    }
}
// File: BlueprintImporter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

public sealed class BlueprintImporter : IBlueprintImporter {
    private readonly IWorkFlowDALUtil _db;
    private readonly IBlueprintReadDAL _bpRead;

    public BlueprintImporter(IWorkFlowDALUtil db, IBlueprintReadDAL bpRead) {
        _db = db ?? throw new ArgumentNullException(nameof(db));
        _bpRead = bpRead ?? throw new ArgumentNullException(nameof(bpRead));
    }

    public async Task<long> ImportDefinitionJsonAsync(int envCode, string envDisplayName, string definitionJson, DbExecutionLoad load = default, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        if (string.IsNullOrWhiteSpace(definitionJson)) throw new ArgumentNullException(nameof(definitionJson));

        using var doc = JsonDocument.Parse(definitionJson);
        var root = doc.RootElement;

        var defDisplayName = TryGetString(root, "displayName") ?? TryGetString(root, "name") ?? throw new InvalidOperationException("Definition JSON missing 'displayName'/'name'.");
        var defDescription = TryGetString(root, "description");

        // 1) environment (upsert by code)
        var envId = await UpsertEnvironmentAsync(envCode, envDisplayName, load);

        // 2) definition (upsert by env + generated name)
        var defId = await UpsertDefinitionAsync(envId, defDisplayName, defDescription, load);

        // 3) def_version (new version number)
        var next = await _bpRead.GetNextDefVersionNumberByEnvCodeAndDefNameAsync(envCode, defDisplayName, load);
        var nextVer = next ?? 1;

        var defVersionId = await InsertDefVersionAsync(defId, nextVer, definitionJson, load);

        // 4) categories
        var categoryMap = await ImportCategoriesAsync(root, load);

        // 5) events
        var eventMapByName = await ImportEventsAsync(defVersionId, root, load);
        var eventMapByCode = eventMapByName.Values.Where(x => x.Code != 0).GroupBy(x => x.Code).ToDictionary(g => g.Key, g => g.First());

        // 6) states (resolve timeout_event using event maps)
        var stateMapByName = await ImportStatesAsync(defVersionId, root, categoryMap, eventMapByName, eventMapByCode, load);

        // 7) transitions
        await ImportTransitionsAsync(defVersionId, root, stateMapByName, eventMapByName, eventMapByCode, load);

        return defVersionId;
    }

    public async Task<long> ImportPolicyJsonAsync(int envCode, string envDisplayName, string policyJson, DbExecutionLoad load = default, CancellationToken ct = default) {
        ct.ThrowIfCancellationRequested();
        if (string.IsNullOrWhiteSpace(policyJson)) throw new ArgumentNullException(nameof(policyJson));

        using var doc = JsonDocument.Parse(policyJson);
        var root = doc.RootElement;

        var defDisplayName = TryGetString(root, "defName") ?? TryGetString(root, "definitionName") ?? TryGetString(root, "displayName") ?? TryGetString(root, "name");
        if (string.IsNullOrWhiteSpace(defDisplayName)) throw new InvalidOperationException("Policy JSON missing defName/definitionName/displayName/name (needed to attach to definition).");

        var envId = await UpsertEnvironmentAsync(envCode, envDisplayName, load);
        var defId = await UpsertDefinitionAsync(envId, defDisplayName!, description: null, load);

        var hash = Hash48(policyJson);

        // policy upsert by hash
        var policyId = await UpsertPolicyAsync(hash, policyJson, load);

        // attach definition-policy
        await _db.ExecAsync(@"INSERT INTO def_policies(definition, policy) VALUES(@defId, @policyId)
                              ON DUPLICATE KEY UPDATE modified = CURRENT_TIMESTAMP()", load,
            new DbArg("defId", defId), new DbArg("policyId", policyId));

        return policyId;
    }

    private async Task<int> UpsertEnvironmentAsync(int envCode, string envDisplayName, DbExecutionLoad load) {
        await _db.ExecAsync(@"INSERT INTO environment(display_name, code) VALUES(@dn, @code)
                              ON DUPLICATE KEY UPDATE display_name = VALUES(display_name)", load,
            new DbArg("dn", envDisplayName), new DbArg("code", envCode));

        var id = await _db.ScalarAsync<int>(@"SELECT id FROM environment WHERE code = @code", load, new DbArg("code", envCode));
        if (id <= 0) throw new InvalidOperationException("Failed to resolve environment id.");
        return id;
    }

    private async Task<int> UpsertDefinitionAsync(int envId, string displayName, string? description, DbExecutionLoad load) {
        await _db.ExecAsync(@"INSERT INTO definition(display_name, description, env) VALUES(@dn, @desc, @env)
                              ON DUPLICATE KEY UPDATE display_name = VALUES(display_name), description = VALUES(description)", load,
            new DbArg("dn", displayName), new DbArg("desc", description), new DbArg("env", envId));

        var id = await _db.ScalarAsync<int>(@"SELECT id FROM definition WHERE env = @env AND name = LCASE(TRIM(@dn))", load,
            new DbArg("env", envId), new DbArg("dn", displayName));
        if (id <= 0) throw new InvalidOperationException("Failed to resolve definition id.");
        return id;
    }

    private async Task<long> InsertDefVersionAsync(int defId, int version, string json, DbExecutionLoad load) {
        await _db.ExecAsync(@"INSERT INTO def_version(version, parent, data) VALUES(@ver, @parent, @data)", load,
            new DbArg("ver", version), new DbArg("parent", defId), new DbArg("data", json));

        var id = await _db.ScalarAsync<long>(@"SELECT id FROM def_version WHERE parent=@parent AND version=@ver", load,
            new DbArg("parent", defId), new DbArg("ver", version));
        if (id <= 0) throw new InvalidOperationException("Failed to resolve def_version id.");
        return id;
    }

    private async Task<Dictionary<string, int>> ImportCategoriesAsync(JsonElement root, DbExecutionLoad load) {
        var map = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        if (!root.TryGetProperty("categories", out var cats) || cats.ValueKind != JsonValueKind.Array)
            return map;

        foreach (var c in cats.EnumerateArray()) {
            var dn = TryGetString(c, "displayName") ?? TryGetString(c, "name");
            if (string.IsNullOrWhiteSpace(dn)) continue;

            await _db.ExecAsync(@"INSERT INTO category(display_name) VALUES(@dn)
                                  ON DUPLICATE KEY UPDATE display_name = VALUES(display_name)", load,
                new DbArg("dn", dn));

            var id = await _db.ScalarAsync<int>(@"SELECT id FROM category WHERE name = LCASE(TRIM(@dn))", load, new DbArg("dn", dn));
            if (id > 0) map[Normalize(dn)] = id;
        }

        return map;
    }

    private async Task<Dictionary<string, EventDef>> ImportEventsAsync(long defVersionId, JsonElement root, DbExecutionLoad load) {
        var map = new Dictionary<string, EventDef>(StringComparer.OrdinalIgnoreCase);

        if (!root.TryGetProperty("events", out var events) || events.ValueKind != JsonValueKind.Array)
            return map;

        foreach (var e in events.EnumerateArray()) {
            var dn = TryGetString(e, "displayName") ?? TryGetString(e, "name");
            var code = TryGetInt(e, "code") ?? 0;
            if (string.IsNullOrWhiteSpace(dn) || code == 0) continue;

            await _db.ExecAsync(@"INSERT INTO events(display_name, code, def_version) VALUES(@dn, @code, @dv)
                                  ON DUPLICATE KEY UPDATE display_name = VALUES(display_name)", load,
                new DbArg("dn", dn), new DbArg("code", code), new DbArg("dv", defVersionId));

            var id = await _db.ScalarAsync<int>(@"SELECT id FROM events WHERE def_version=@dv AND code=@code AND name=LCASE(TRIM(@dn))", load,
                new DbArg("dv", defVersionId), new DbArg("code", code), new DbArg("dn", dn));

            var def = new EventDef { Id = id, Code = code, Name = Normalize(dn), DisplayName = dn };
            map[Normalize(dn)] = def;
        }

        return map;
    }

    private async Task<Dictionary<string, StateDef>> ImportStatesAsync(
        long defVersionId,
        JsonElement root,
        Dictionary<string, int> categoryMap,
        Dictionary<string, EventDef> eventByName,
        Dictionary<int, EventDef> eventByCode,
        DbExecutionLoad load
    ) {
        var map = new Dictionary<string, StateDef>(StringComparer.OrdinalIgnoreCase);

        if (!root.TryGetProperty("states", out var states) || states.ValueKind != JsonValueKind.Array)
            return map;

        foreach (var s in states.EnumerateArray()) {
            var dn = TryGetString(s, "displayName") ?? TryGetString(s, "name");
            if (string.IsNullOrWhiteSpace(dn)) continue;

            var flags = (TryGetInt(s, "flags") ?? 0);
            var timeoutMinutes = TryGetInt(s, "timeoutMinutes");
            long? timeoutEventId = null;

            // allow "timeoutEvent" either by name or by code
            var teName = TryGetString(s, "timeoutEvent");
            var teCode = TryGetInt(s, "timeoutEventCode");
            if (!string.IsNullOrWhiteSpace(teName) && eventByName.TryGetValue(Normalize(teName), out var teN)) timeoutEventId = teN.Id;
            else if (teCode.HasValue && eventByCode.TryGetValue(teCode.Value, out var teC)) timeoutEventId = teC.Id;

            var catName = TryGetString(s, "category");
            var catId = 0;
            if (!string.IsNullOrWhiteSpace(catName) && categoryMap.TryGetValue(Normalize(catName), out var cid)) catId = cid;

            await _db.ExecAsync(@"INSERT INTO state(category, display_name, flags, timeout_minutes, timeout_event, def_version)
                                  VALUES(@cat, @dn, @flags, @tm, @te, @dv)", load,
                new DbArg("cat", catId), new DbArg("dn", dn), new DbArg("flags", flags), new DbArg("tm", timeoutMinutes), new DbArg("te", timeoutEventId), new DbArg("dv", defVersionId));

            var id = await _db.ScalarAsync<int>(@"SELECT id FROM state WHERE def_version=@dv AND name=LCASE(TRIM(@dn))", load,
                new DbArg("dv", defVersionId), new DbArg("dn", dn));

            var def = new StateDef {
                Id = id,
                Name = Normalize(dn),
                DisplayName = dn,
                Flags = (uint)flags,
                TimeoutMinutes = timeoutMinutes,
                TimeoutEventId = timeoutEventId,
                IsInitial = (((uint)flags) & (uint)LifeCycleStateFlag.IsInitial) != 0
            };
            map[Normalize(dn)] = def;
        }

        return map;
    }

    private async Task ImportTransitionsAsync(
        long defVersionId,
        JsonElement root,
        Dictionary<string, StateDef> statesByName,
        Dictionary<string, EventDef> eventsByName,
        Dictionary<int, EventDef> eventsByCode,
        DbExecutionLoad load
    ) {
        if (!root.TryGetProperty("transitions", out var trans) || trans.ValueKind != JsonValueKind.Array)
            return;

        foreach (var t in trans.EnumerateArray()) {
            var fromName = TryGetString(t, "from") ?? TryGetString(t, "fromState");
            var toName = TryGetString(t, "to") ?? TryGetString(t, "toState");
            if (string.IsNullOrWhiteSpace(fromName) || string.IsNullOrWhiteSpace(toName)) continue;

            var evName = TryGetString(t, "event");
            var evCode = TryGetInt(t, "eventCode");

            if (!statesByName.TryGetValue(Normalize(fromName), out var from)) continue;
            if (!statesByName.TryGetValue(Normalize(toName), out var to)) continue;

            EventDef? ev = null;
            if (!string.IsNullOrWhiteSpace(evName) && eventsByName.TryGetValue(Normalize(evName), out var e1)) ev = e1;
            else if (evCode.HasValue && eventsByCode.TryGetValue(evCode.Value, out var e2)) ev = e2;

            if (ev == null) continue;

            await _db.ExecAsync(@"INSERT INTO transition(from_state, to_state, def_version, event)
                                  VALUES(@fs, @ts, @dv, @ev)
                                  ON DUPLICATE KEY UPDATE id=id", load,
                new DbArg("fs", from.Id), new DbArg("ts", to.Id), new DbArg("dv", defVersionId), new DbArg("ev", ev.Id));
        }
    }

    private async Task<long> UpsertPolicyAsync(string hash, string json, DbExecutionLoad load) {
        await _db.ExecAsync(@"INSERT INTO policy(hash, content) VALUES(@hash, @content)
                              ON DUPLICATE KEY UPDATE content = VALUES(content)", load,
            new DbArg("hash", hash), new DbArg("content", json));

        var id = await _db.ScalarAsync<long>(@"SELECT id FROM policy WHERE hash = @hash", load, new DbArg("hash", hash));
        if (id <= 0) throw new InvalidOperationException("Failed to resolve policy id.");
        return id;
    }

    private static string Normalize(string s) => (s ?? string.Empty).Trim().ToLowerInvariant();

    private static string? TryGetString(JsonElement e, string prop) {
        if (!e.TryGetProperty(prop, out var v)) return null;
        return v.ValueKind == JsonValueKind.String ? v.GetString() : v.ToString();
    }

    private static int? TryGetInt(JsonElement e, string prop) {
        if (!e.TryGetProperty(prop, out var v)) return null;
        if (v.ValueKind == JsonValueKind.Number && v.TryGetInt32(out var i)) return i;
        if (v.ValueKind == JsonValueKind.String && int.TryParse(v.GetString(), out var j)) return j;
        return null;
    }

    private static string Hash48(string input) {
        using var sha = SHA256.Create();
        var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input ?? string.Empty));
        var hex = BitConverter.ToString(bytes).Replace("-", "").ToLowerInvariant();
        return hex.Length <= 48 ? hex : hex.Substring(0, 48);
    }
}
